
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  000015f6  0000168a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000015f6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000037a  00800106  00800106  00001690  2**0
                  ALLOC
  3 .debug_aranges 000000e0  00000000  00000000  00001690  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000049f  00000000  00000000  00001770  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001bec  00000000  00000000  00001c0f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000926  00000000  00000000  000037fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000017bf  00000000  00000000  00004121  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000380  00000000  00000000  000058e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000cea  00000000  00000000  00005c60  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000e08  00000000  00000000  0000694a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  00007752  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
       4:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
       8:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
       c:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      10:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      14:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      18:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      1c:	0c 94 5e 0a 	jmp	0x14bc	; 0x14bc <__vector_7>
      20:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      24:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      28:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      2c:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      30:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      34:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      38:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      3c:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      40:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      44:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      48:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      4c:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      50:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      54:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>
      58:	0c 94 4b 00 	jmp	0x96	; 0x96 <__bad_interrupt>

0000005c <__ctors_end>:
      5c:	11 24       	eor	r1, r1
      5e:	1f be       	out	0x3f, r1	; 63
      60:	cf ef       	ldi	r28, 0xFF	; 255
      62:	d4 e0       	ldi	r29, 0x04	; 4
      64:	de bf       	out	0x3e, r29	; 62
      66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_copy_data>:
      68:	11 e0       	ldi	r17, 0x01	; 1
      6a:	a0 e0       	ldi	r26, 0x00	; 0
      6c:	b1 e0       	ldi	r27, 0x01	; 1
      6e:	e6 ef       	ldi	r30, 0xF6	; 246
      70:	f5 e1       	ldi	r31, 0x15	; 21
      72:	02 c0       	rjmp	.+4      	; 0x78 <.do_copy_data_start>

00000074 <.do_copy_data_loop>:
      74:	05 90       	lpm	r0, Z+
      76:	0d 92       	st	X+, r0

00000078 <.do_copy_data_start>:
      78:	a6 30       	cpi	r26, 0x06	; 6
      7a:	b1 07       	cpc	r27, r17
      7c:	d9 f7       	brne	.-10     	; 0x74 <.do_copy_data_loop>

0000007e <__do_clear_bss>:
      7e:	14 e0       	ldi	r17, 0x04	; 4
      80:	a6 e0       	ldi	r26, 0x06	; 6
      82:	b1 e0       	ldi	r27, 0x01	; 1
      84:	01 c0       	rjmp	.+2      	; 0x88 <.do_clear_bss_start>

00000086 <.do_clear_bss_loop>:
      86:	1d 92       	st	X+, r1

00000088 <.do_clear_bss_start>:
      88:	a0 38       	cpi	r26, 0x80	; 128
      8a:	b1 07       	cpc	r27, r17
      8c:	e1 f7       	brne	.-8      	; 0x86 <.do_clear_bss_loop>
      8e:	0e 94 bf 0a 	call	0x157e	; 0x157e <main>
      92:	0c 94 f9 0a 	jmp	0x15f2	; 0x15f2 <_exit>

00000096 <__bad_interrupt>:
      96:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000009a <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
      9a:	0f 93       	push	r16
      9c:	1f 93       	push	r17
      9e:	cf 93       	push	r28
      a0:	df 93       	push	r29
      a2:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
      a4:	80 81       	ld	r24, Z
      a6:	88 23       	and	r24, r24
      a8:	19 f4       	brne	.+6      	; 0xb0 <xCoRoutineRemoveFromEventList+0x16>
      aa:	c0 e0       	ldi	r28, 0x00	; 0
      ac:	d0 e0       	ldi	r29, 0x00	; 0
      ae:	05 c0       	rjmp	.+10     	; 0xba <xCoRoutineRemoveFromEventList+0x20>
      b0:	05 80       	ldd	r0, Z+5	; 0x05
      b2:	f6 81       	ldd	r31, Z+6	; 0x06
      b4:	e0 2d       	mov	r30, r0
      b6:	c6 81       	ldd	r28, Z+6	; 0x06
      b8:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
      ba:	8e 01       	movw	r16, r28
      bc:	04 5f       	subi	r16, 0xF4	; 244
      be:	1f 4f       	sbci	r17, 0xFF	; 255
      c0:	c8 01       	movw	r24, r16
      c2:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
      c6:	87 e3       	ldi	r24, 0x37	; 55
      c8:	91 e0       	ldi	r25, 0x01	; 1
      ca:	b8 01       	movw	r22, r16
      cc:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
      d0:	20 e0       	ldi	r18, 0x00	; 0
      d2:	e0 91 06 01 	lds	r30, 0x0106
      d6:	f0 91 07 01 	lds	r31, 0x0107
      da:	9e 89       	ldd	r25, Y+22	; 0x16
      dc:	86 89       	ldd	r24, Z+22	; 0x16
      de:	98 17       	cp	r25, r24
      e0:	08 f0       	brcs	.+2      	; 0xe4 <xCoRoutineRemoveFromEventList+0x4a>
      e2:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
      e4:	82 2f       	mov	r24, r18
      e6:	df 91       	pop	r29
      e8:	cf 91       	pop	r28
      ea:	1f 91       	pop	r17
      ec:	0f 91       	pop	r16
      ee:	08 95       	ret

000000f0 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
      f0:	ff 92       	push	r15
      f2:	0f 93       	push	r16
      f4:	1f 93       	push	r17
      f6:	cf 93       	push	r28
      f8:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
      fa:	99 e0       	ldi	r25, 0x09	; 9
      fc:	f9 2e       	mov	r15, r25
      fe:	28 c0       	rjmp	.+80     	; 0x150 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     100:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     102:	80 91 37 01 	lds	r24, 0x0137
     106:	88 23       	and	r24, r24
     108:	19 f4       	brne	.+6      	; 0x110 <vCoRoutineSchedule+0x20>
     10a:	c0 e0       	ldi	r28, 0x00	; 0
     10c:	d0 e0       	ldi	r29, 0x00	; 0
     10e:	06 c0       	rjmp	.+12     	; 0x11c <vCoRoutineSchedule+0x2c>
     110:	e0 91 3c 01 	lds	r30, 0x013C
     114:	f0 91 3d 01 	lds	r31, 0x013D
     118:	c6 81       	ldd	r28, Z+6	; 0x06
     11a:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     11c:	ce 01       	movw	r24, r28
     11e:	0c 96       	adiw	r24, 0x0c	; 12
     120:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     124:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     126:	8e 01       	movw	r16, r28
     128:	0e 5f       	subi	r16, 0xFE	; 254
     12a:	1f 4f       	sbci	r17, 0xFF	; 255
     12c:	c8 01       	movw	r24, r16
     12e:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     132:	9e 89       	ldd	r25, Y+22	; 0x16
     134:	80 91 08 01 	lds	r24, 0x0108
     138:	89 17       	cp	r24, r25
     13a:	10 f4       	brcc	.+4      	; 0x140 <vCoRoutineSchedule+0x50>
     13c:	90 93 08 01 	sts	0x0108, r25
     140:	9f 9d       	mul	r25, r15
     142:	c0 01       	movw	r24, r0
     144:	11 24       	eor	r1, r1
     146:	81 5f       	subi	r24, 0xF1	; 241
     148:	9e 4f       	sbci	r25, 0xFE	; 254
     14a:	b8 01       	movw	r22, r16
     14c:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
     150:	80 91 37 01 	lds	r24, 0x0137
     154:	88 23       	and	r24, r24
     156:	a1 f6       	brne	.-88     	; 0x100 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     158:	0e 94 9c 05 	call	0xb38	; 0xb38 <xTaskGetTickCount>
     15c:	20 91 09 01 	lds	r18, 0x0109
     160:	30 91 0a 01 	lds	r19, 0x010A
     164:	82 1b       	sub	r24, r18
     166:	93 0b       	sbc	r25, r19
     168:	90 93 0c 01 	sts	0x010C, r25
     16c:	80 93 0b 01 	sts	0x010B, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     170:	89 e0       	ldi	r24, 0x09	; 9
     172:	f8 2e       	mov	r15, r24
     174:	54 c0       	rjmp	.+168    	; 0x21e <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     176:	01 96       	adiw	r24, 0x01	; 1
     178:	90 93 0e 01 	sts	0x010E, r25
     17c:	80 93 0d 01 	sts	0x010D, r24
		xPassedTicks--;
     180:	21 50       	subi	r18, 0x01	; 1
     182:	30 40       	sbci	r19, 0x00	; 0
     184:	30 93 0c 01 	sts	0x010C, r19
     188:	20 93 0b 01 	sts	0x010B, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     18c:	89 2b       	or	r24, r25
     18e:	c9 f5       	brne	.+114    	; 0x202 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     190:	20 91 33 01 	lds	r18, 0x0133
     194:	30 91 34 01 	lds	r19, 0x0134
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     198:	80 91 35 01 	lds	r24, 0x0135
     19c:	90 91 36 01 	lds	r25, 0x0136
     1a0:	90 93 34 01 	sts	0x0134, r25
     1a4:	80 93 33 01 	sts	0x0133, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     1a8:	30 93 36 01 	sts	0x0136, r19
     1ac:	20 93 35 01 	sts	0x0135, r18
     1b0:	28 c0       	rjmp	.+80     	; 0x202 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     1b2:	20 91 0d 01 	lds	r18, 0x010D
     1b6:	30 91 0e 01 	lds	r19, 0x010E
     1ba:	8a 81       	ldd	r24, Y+2	; 0x02
     1bc:	9b 81       	ldd	r25, Y+3	; 0x03
     1be:	28 17       	cp	r18, r24
     1c0:	39 07       	cpc	r19, r25
     1c2:	68 f1       	brcs	.+90     	; 0x21e <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     1c4:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     1c6:	8e 01       	movw	r16, r28
     1c8:	0e 5f       	subi	r16, 0xFE	; 254
     1ca:	1f 4f       	sbci	r17, 0xFF	; 255
     1cc:	c8 01       	movw	r24, r16
     1ce:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     1d2:	8c 89       	ldd	r24, Y+20	; 0x14
     1d4:	9d 89       	ldd	r25, Y+21	; 0x15
     1d6:	89 2b       	or	r24, r25
     1d8:	21 f0       	breq	.+8      	; 0x1e2 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     1da:	ce 01       	movw	r24, r28
     1dc:	0c 96       	adiw	r24, 0x0c	; 12
     1de:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     1e2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     1e4:	9e 89       	ldd	r25, Y+22	; 0x16
     1e6:	80 91 08 01 	lds	r24, 0x0108
     1ea:	89 17       	cp	r24, r25
     1ec:	10 f4       	brcc	.+4      	; 0x1f2 <vCoRoutineSchedule+0x102>
     1ee:	90 93 08 01 	sts	0x0108, r25
     1f2:	9f 9d       	mul	r25, r15
     1f4:	c0 01       	movw	r24, r0
     1f6:	11 24       	eor	r1, r1
     1f8:	81 5f       	subi	r24, 0xF1	; 241
     1fa:	9e 4f       	sbci	r25, 0xFE	; 254
     1fc:	b8 01       	movw	r22, r16
     1fe:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
     202:	e0 91 33 01 	lds	r30, 0x0133
     206:	f0 91 34 01 	lds	r31, 0x0134
     20a:	80 81       	ld	r24, Z
     20c:	88 23       	and	r24, r24
     20e:	39 f0       	breq	.+14     	; 0x21e <vCoRoutineSchedule+0x12e>
     210:	05 80       	ldd	r0, Z+5	; 0x05
     212:	f6 81       	ldd	r31, Z+6	; 0x06
     214:	e0 2d       	mov	r30, r0
     216:	c6 81       	ldd	r28, Z+6	; 0x06
     218:	d7 81       	ldd	r29, Z+7	; 0x07
     21a:	20 97       	sbiw	r28, 0x00	; 0
     21c:	51 f6       	brne	.-108    	; 0x1b2 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     21e:	20 91 0b 01 	lds	r18, 0x010B
     222:	30 91 0c 01 	lds	r19, 0x010C
     226:	80 91 0d 01 	lds	r24, 0x010D
     22a:	90 91 0e 01 	lds	r25, 0x010E
     22e:	21 15       	cp	r18, r1
     230:	31 05       	cpc	r19, r1
     232:	09 f0       	breq	.+2      	; 0x236 <vCoRoutineSchedule+0x146>
     234:	a0 cf       	rjmp	.-192    	; 0x176 <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     236:	90 93 0a 01 	sts	0x010A, r25
     23a:	80 93 09 01 	sts	0x0109, r24
     23e:	90 91 08 01 	lds	r25, 0x0108

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     242:	29 e0       	ldi	r18, 0x09	; 9
     244:	06 c0       	rjmp	.+12     	; 0x252 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     246:	99 23       	and	r25, r25
     248:	19 f4       	brne	.+6      	; 0x250 <vCoRoutineSchedule+0x160>
     24a:	10 92 08 01 	sts	0x0108, r1
     24e:	32 c0       	rjmp	.+100    	; 0x2b4 <vCoRoutineSchedule+0x1c4>
     250:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     252:	92 9f       	mul	r25, r18
     254:	d0 01       	movw	r26, r0
     256:	11 24       	eor	r1, r1
     258:	a1 5f       	subi	r26, 0xF1	; 241
     25a:	be 4f       	sbci	r27, 0xFE	; 254
     25c:	8c 91       	ld	r24, X
     25e:	88 23       	and	r24, r24
     260:	91 f3       	breq	.-28     	; 0x246 <vCoRoutineSchedule+0x156>
     262:	90 93 08 01 	sts	0x0108, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     266:	11 96       	adiw	r26, 0x01	; 1
     268:	ed 91       	ld	r30, X+
     26a:	fc 91       	ld	r31, X
     26c:	12 97       	sbiw	r26, 0x02	; 2
     26e:	02 80       	ldd	r0, Z+2	; 0x02
     270:	f3 81       	ldd	r31, Z+3	; 0x03
     272:	e0 2d       	mov	r30, r0
     274:	12 96       	adiw	r26, 0x02	; 2
     276:	fc 93       	st	X, r31
     278:	ee 93       	st	-X, r30
     27a:	11 97       	sbiw	r26, 0x01	; 1
     27c:	cd 01       	movw	r24, r26
     27e:	03 96       	adiw	r24, 0x03	; 3
     280:	e8 17       	cp	r30, r24
     282:	f9 07       	cpc	r31, r25
     284:	31 f4       	brne	.+12     	; 0x292 <vCoRoutineSchedule+0x1a2>
     286:	82 81       	ldd	r24, Z+2	; 0x02
     288:	93 81       	ldd	r25, Z+3	; 0x03
     28a:	12 96       	adiw	r26, 0x02	; 2
     28c:	9c 93       	st	X, r25
     28e:	8e 93       	st	-X, r24
     290:	11 97       	sbiw	r26, 0x01	; 1
     292:	11 96       	adiw	r26, 0x01	; 1
     294:	ed 91       	ld	r30, X+
     296:	fc 91       	ld	r31, X
     298:	12 97       	sbiw	r26, 0x02	; 2
     29a:	06 80       	ldd	r0, Z+6	; 0x06
     29c:	f7 81       	ldd	r31, Z+7	; 0x07
     29e:	e0 2d       	mov	r30, r0
     2a0:	f0 93 07 01 	sts	0x0107, r31
     2a4:	e0 93 06 01 	sts	0x0106, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     2a8:	20 81       	ld	r18, Z
     2aa:	31 81       	ldd	r19, Z+1	; 0x01
     2ac:	cf 01       	movw	r24, r30
     2ae:	67 89       	ldd	r22, Z+23	; 0x17
     2b0:	f9 01       	movw	r30, r18
     2b2:	09 95       	icall

	return;
}
     2b4:	df 91       	pop	r29
     2b6:	cf 91       	pop	r28
     2b8:	1f 91       	pop	r17
     2ba:	0f 91       	pop	r16
     2bc:	ff 90       	pop	r15
     2be:	08 95       	ret

000002c0 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     2c0:	0f 93       	push	r16
     2c2:	1f 93       	push	r17
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
     2c8:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     2ca:	00 91 0d 01 	lds	r16, 0x010D
     2ce:	10 91 0e 01 	lds	r17, 0x010E
     2d2:	08 0f       	add	r16, r24
     2d4:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2d6:	80 91 06 01 	lds	r24, 0x0106
     2da:	90 91 07 01 	lds	r25, 0x0107
     2de:	02 96       	adiw	r24, 0x02	; 2
     2e0:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     2e4:	e0 91 06 01 	lds	r30, 0x0106
     2e8:	f0 91 07 01 	lds	r31, 0x0107
     2ec:	13 83       	std	Z+3, r17	; 0x03
     2ee:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     2f0:	80 91 0d 01 	lds	r24, 0x010D
     2f4:	90 91 0e 01 	lds	r25, 0x010E
     2f8:	bf 01       	movw	r22, r30
     2fa:	6e 5f       	subi	r22, 0xFE	; 254
     2fc:	7f 4f       	sbci	r23, 0xFF	; 255
     2fe:	08 17       	cp	r16, r24
     300:	19 07       	cpc	r17, r25
     302:	28 f4       	brcc	.+10     	; 0x30e <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     304:	80 91 35 01 	lds	r24, 0x0135
     308:	90 91 36 01 	lds	r25, 0x0136
     30c:	04 c0       	rjmp	.+8      	; 0x316 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     30e:	80 91 33 01 	lds	r24, 0x0133
     312:	90 91 34 01 	lds	r25, 0x0134
     316:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListInsert>
	}

	if( pxEventList )
     31a:	20 97       	sbiw	r28, 0x00	; 0
     31c:	49 f0       	breq	.+18     	; 0x330 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     31e:	60 91 06 01 	lds	r22, 0x0106
     322:	70 91 07 01 	lds	r23, 0x0107
     326:	64 5f       	subi	r22, 0xF4	; 244
     328:	7f 4f       	sbci	r23, 0xFF	; 255
     32a:	ce 01       	movw	r24, r28
     32c:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListInsert>
	}
}
     330:	df 91       	pop	r29
     332:	cf 91       	pop	r28
     334:	1f 91       	pop	r17
     336:	0f 91       	pop	r16
     338:	08 95       	ret

0000033a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     33a:	af 92       	push	r10
     33c:	bf 92       	push	r11
     33e:	cf 92       	push	r12
     340:	df 92       	push	r13
     342:	ef 92       	push	r14
     344:	ff 92       	push	r15
     346:	0f 93       	push	r16
     348:	1f 93       	push	r17
     34a:	cf 93       	push	r28
     34c:	df 93       	push	r29
     34e:	6c 01       	movw	r12, r24
     350:	b6 2e       	mov	r11, r22
     352:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     354:	8a e1       	ldi	r24, 0x1A	; 26
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	0e 94 58 09 	call	0x12b0	; 0x12b0 <pvPortMalloc>
     35c:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     35e:	00 97       	sbiw	r24, 0x00	; 0
     360:	11 f4       	brne	.+4      	; 0x366 <xCoRoutineCreate+0x2c>
     362:	8f ef       	ldi	r24, 0xFF	; 255
     364:	59 c0       	rjmp	.+178    	; 0x418 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     366:	80 91 06 01 	lds	r24, 0x0106
     36a:	90 91 07 01 	lds	r25, 0x0107
     36e:	89 2b       	or	r24, r25
     370:	21 f5       	brne	.+72     	; 0x3ba <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     372:	d0 93 07 01 	sts	0x0107, r29
     376:	c0 93 06 01 	sts	0x0106, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     37a:	8f e0       	ldi	r24, 0x0F	; 15
     37c:	91 e0       	ldi	r25, 0x01	; 1
     37e:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
     382:	88 e1       	ldi	r24, 0x18	; 24
     384:	91 e0       	ldi	r25, 0x01	; 1
     386:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     38a:	21 e2       	ldi	r18, 0x21	; 33
     38c:	e2 2e       	mov	r14, r18
     38e:	21 e0       	ldi	r18, 0x01	; 1
     390:	f2 2e       	mov	r15, r18
     392:	c7 01       	movw	r24, r14
     394:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     398:	0a e2       	ldi	r16, 0x2A	; 42
     39a:	11 e0       	ldi	r17, 0x01	; 1
     39c:	c8 01       	movw	r24, r16
     39e:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     3a2:	87 e3       	ldi	r24, 0x37	; 55
     3a4:	91 e0       	ldi	r25, 0x01	; 1
     3a6:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     3aa:	f0 92 34 01 	sts	0x0134, r15
     3ae:	e0 92 33 01 	sts	0x0133, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     3b2:	10 93 36 01 	sts	0x0136, r17
     3b6:	00 93 35 01 	sts	0x0135, r16
     3ba:	eb 2c       	mov	r14, r11
     3bc:	bb 20       	and	r11, r11
     3be:	11 f0       	breq	.+4      	; 0x3c4 <xCoRoutineCreate+0x8a>
     3c0:	ee 24       	eor	r14, r14
     3c2:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     3c4:	19 8e       	std	Y+25, r1	; 0x19
     3c6:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     3c8:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     3ca:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     3cc:	fe 01       	movw	r30, r28
     3ce:	c1 92       	st	Z+, r12
     3d0:	d1 92       	st	Z+, r13
     3d2:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     3d4:	cf 01       	movw	r24, r30
     3d6:	0e 94 27 02 	call	0x44e	; 0x44e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     3da:	ce 01       	movw	r24, r28
     3dc:	0c 96       	adiw	r24, 0x0c	; 12
     3de:	0e 94 27 02 	call	0x44e	; 0x44e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     3e2:	d9 87       	std	Y+9, r29	; 0x09
     3e4:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     3e6:	db 8b       	std	Y+19, r29	; 0x13
     3e8:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     3ea:	84 e0       	ldi	r24, 0x04	; 4
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	8e 19       	sub	r24, r14
     3f0:	91 09       	sbc	r25, r1
     3f2:	9d 87       	std	Y+13, r25	; 0x0d
     3f4:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     3f6:	9e 89       	ldd	r25, Y+22	; 0x16
     3f8:	80 91 08 01 	lds	r24, 0x0108
     3fc:	89 17       	cp	r24, r25
     3fe:	10 f4       	brcc	.+4      	; 0x404 <xCoRoutineCreate+0xca>
     400:	90 93 08 01 	sts	0x0108, r25
     404:	89 e0       	ldi	r24, 0x09	; 9
     406:	98 9f       	mul	r25, r24
     408:	c0 01       	movw	r24, r0
     40a:	11 24       	eor	r1, r1
     40c:	81 5f       	subi	r24, 0xF1	; 241
     40e:	9e 4f       	sbci	r25, 0xFE	; 254
     410:	b8 01       	movw	r22, r16
     412:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
     416:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
     418:	df 91       	pop	r29
     41a:	cf 91       	pop	r28
     41c:	1f 91       	pop	r17
     41e:	0f 91       	pop	r16
     420:	ff 90       	pop	r15
     422:	ef 90       	pop	r14
     424:	df 90       	pop	r13
     426:	cf 90       	pop	r12
     428:	bf 90       	pop	r11
     42a:	af 90       	pop	r10
     42c:	08 95       	ret

0000042e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     42e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     430:	9c 01       	movw	r18, r24
     432:	2d 5f       	subi	r18, 0xFD	; 253
     434:	3f 4f       	sbci	r19, 0xFF	; 255
     436:	32 83       	std	Z+2, r19	; 0x02
     438:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     43a:	8f ef       	ldi	r24, 0xFF	; 255
     43c:	9f ef       	ldi	r25, 0xFF	; 255
     43e:	94 83       	std	Z+4, r25	; 0x04
     440:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     442:	36 83       	std	Z+6, r19	; 0x06
     444:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     446:	30 87       	std	Z+8, r19	; 0x08
     448:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
     44a:	10 82       	st	Z, r1
}
     44c:	08 95       	ret

0000044e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     44e:	fc 01       	movw	r30, r24
     450:	11 86       	std	Z+9, r1	; 0x09
     452:	10 86       	std	Z+8, r1	; 0x08
}
     454:	08 95       	ret

00000456 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     456:	cf 93       	push	r28
     458:	df 93       	push	r29
     45a:	ac 01       	movw	r20, r24
     45c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     45e:	ec 01       	movw	r28, r24
     460:	29 81       	ldd	r18, Y+1	; 0x01
     462:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     464:	f9 01       	movw	r30, r18
     466:	82 81       	ldd	r24, Z+2	; 0x02
     468:	93 81       	ldd	r25, Z+3	; 0x03
     46a:	13 96       	adiw	r26, 0x03	; 3
     46c:	9c 93       	st	X, r25
     46e:	8e 93       	st	-X, r24
     470:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     472:	89 81       	ldd	r24, Y+1	; 0x01
     474:	9a 81       	ldd	r25, Y+2	; 0x02
     476:	15 96       	adiw	r26, 0x05	; 5
     478:	9c 93       	st	X, r25
     47a:	8e 93       	st	-X, r24
     47c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     47e:	02 80       	ldd	r0, Z+2	; 0x02
     480:	f3 81       	ldd	r31, Z+3	; 0x03
     482:	e0 2d       	mov	r30, r0
     484:	75 83       	std	Z+5, r23	; 0x05
     486:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     488:	e9 01       	movw	r28, r18
     48a:	7b 83       	std	Y+3, r23	; 0x03
     48c:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     48e:	fa 01       	movw	r30, r20
     490:	72 83       	std	Z+2, r23	; 0x02
     492:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     494:	19 96       	adiw	r26, 0x09	; 9
     496:	5c 93       	st	X, r21
     498:	4e 93       	st	-X, r20
     49a:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     49c:	80 81       	ld	r24, Z
     49e:	8f 5f       	subi	r24, 0xFF	; 255
     4a0:	80 83       	st	Z, r24
}
     4a2:	df 91       	pop	r29
     4a4:	cf 91       	pop	r28
     4a6:	08 95       	ret

000004a8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     4a8:	cf 93       	push	r28
     4aa:	df 93       	push	r29
     4ac:	9c 01       	movw	r18, r24
     4ae:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     4b0:	48 81       	ld	r20, Y
     4b2:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     4b4:	8f ef       	ldi	r24, 0xFF	; 255
     4b6:	4f 3f       	cpi	r20, 0xFF	; 255
     4b8:	58 07       	cpc	r21, r24
     4ba:	21 f4       	brne	.+8      	; 0x4c4 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     4bc:	f9 01       	movw	r30, r18
     4be:	a7 81       	ldd	r26, Z+7	; 0x07
     4c0:	b0 85       	ldd	r27, Z+8	; 0x08
     4c2:	10 c0       	rjmp	.+32     	; 0x4e4 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     4c4:	d9 01       	movw	r26, r18
     4c6:	13 96       	adiw	r26, 0x03	; 3
     4c8:	04 c0       	rjmp	.+8      	; 0x4d2 <vListInsert+0x2a>
     4ca:	12 96       	adiw	r26, 0x02	; 2
     4cc:	0d 90       	ld	r0, X+
     4ce:	bc 91       	ld	r27, X
     4d0:	a0 2d       	mov	r26, r0
     4d2:	12 96       	adiw	r26, 0x02	; 2
     4d4:	ed 91       	ld	r30, X+
     4d6:	fc 91       	ld	r31, X
     4d8:	13 97       	sbiw	r26, 0x03	; 3
     4da:	80 81       	ld	r24, Z
     4dc:	91 81       	ldd	r25, Z+1	; 0x01
     4de:	48 17       	cp	r20, r24
     4e0:	59 07       	cpc	r21, r25
     4e2:	98 f7       	brcc	.-26     	; 0x4ca <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4e4:	12 96       	adiw	r26, 0x02	; 2
     4e6:	ed 91       	ld	r30, X+
     4e8:	fc 91       	ld	r31, X
     4ea:	13 97       	sbiw	r26, 0x03	; 3
     4ec:	fb 83       	std	Y+3, r31	; 0x03
     4ee:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     4f0:	d5 83       	std	Z+5, r29	; 0x05
     4f2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4f4:	bd 83       	std	Y+5, r27	; 0x05
     4f6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     4f8:	13 96       	adiw	r26, 0x03	; 3
     4fa:	dc 93       	st	X, r29
     4fc:	ce 93       	st	-X, r28
     4fe:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     500:	39 87       	std	Y+9, r19	; 0x09
     502:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     504:	f9 01       	movw	r30, r18
     506:	80 81       	ld	r24, Z
     508:	8f 5f       	subi	r24, 0xFF	; 255
     50a:	80 83       	st	Z, r24
}
     50c:	df 91       	pop	r29
     50e:	cf 91       	pop	r28
     510:	08 95       	ret

00000512 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     512:	cf 93       	push	r28
     514:	df 93       	push	r29
     516:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     518:	12 96       	adiw	r26, 0x02	; 2
     51a:	ed 91       	ld	r30, X+
     51c:	fc 91       	ld	r31, X
     51e:	13 97       	sbiw	r26, 0x03	; 3
     520:	14 96       	adiw	r26, 0x04	; 4
     522:	8d 91       	ld	r24, X+
     524:	9c 91       	ld	r25, X
     526:	15 97       	sbiw	r26, 0x05	; 5
     528:	95 83       	std	Z+5, r25	; 0x05
     52a:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     52c:	14 96       	adiw	r26, 0x04	; 4
     52e:	cd 91       	ld	r28, X+
     530:	dc 91       	ld	r29, X
     532:	15 97       	sbiw	r26, 0x05	; 5
     534:	fb 83       	std	Y+3, r31	; 0x03
     536:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     538:	18 96       	adiw	r26, 0x08	; 8
     53a:	ed 91       	ld	r30, X+
     53c:	fc 91       	ld	r31, X
     53e:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     540:	81 81       	ldd	r24, Z+1	; 0x01
     542:	92 81       	ldd	r25, Z+2	; 0x02
     544:	8a 17       	cp	r24, r26
     546:	9b 07       	cpc	r25, r27
     548:	11 f4       	brne	.+4      	; 0x54e <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     54a:	d2 83       	std	Z+2, r29	; 0x02
     54c:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     54e:	19 96       	adiw	r26, 0x09	; 9
     550:	1c 92       	st	X, r1
     552:	1e 92       	st	-X, r1
     554:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
     556:	80 81       	ld	r24, Z
     558:	81 50       	subi	r24, 0x01	; 1
     55a:	80 83       	st	Z, r24
}
     55c:	df 91       	pop	r29
     55e:	cf 91       	pop	r28
     560:	08 95       	ret

00000562 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
     562:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
     564:	0f b6       	in	r0, 0x3f	; 63
     566:	f8 94       	cli
     568:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     56a:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     56c:	0f 90       	pop	r0
     56e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     570:	08 95       	ret

00000572 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
     572:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
     574:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     576:	08 95       	ret

00000578 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
     578:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     57a:	82 8d       	ldd	r24, Z+26	; 0x1a
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	88 23       	and	r24, r24
     580:	09 f4       	brne	.+2      	; 0x584 <xQueueIsQueueEmptyFromISR+0xc>
     582:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
     584:	89 2f       	mov	r24, r25
     586:	08 95       	ret

00000588 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     588:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     58a:	92 8d       	ldd	r25, Z+26	; 0x1a
     58c:	20 e0       	ldi	r18, 0x00	; 0
     58e:	83 8d       	ldd	r24, Z+27	; 0x1b
     590:	98 17       	cp	r25, r24
     592:	09 f4       	brne	.+2      	; 0x596 <xQueueIsQueueFullFromISR+0xe>
     594:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
     596:	82 2f       	mov	r24, r18
     598:	08 95       	ret

0000059a <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     59a:	0f 93       	push	r16
     59c:	1f 93       	push	r17
     59e:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     5a0:	fc 01       	movw	r30, r24
     5a2:	80 81       	ld	r24, Z
     5a4:	91 81       	ldd	r25, Z+1	; 0x01
     5a6:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortFree>
	vPortFree( pxQueue );
     5aa:	c8 01       	movw	r24, r16
     5ac:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortFree>
}
     5b0:	1f 91       	pop	r17
     5b2:	0f 91       	pop	r16
     5b4:	08 95       	ret

000005b6 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     5b6:	0f 93       	push	r16
     5b8:	1f 93       	push	r17
     5ba:	cf 93       	push	r28
     5bc:	df 93       	push	r29
     5be:	ec 01       	movw	r28, r24
     5c0:	fb 01       	movw	r30, r22
     5c2:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     5c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
     5c6:	88 23       	and	r24, r24
     5c8:	81 f1       	breq	.+96     	; 0x62a <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     5ca:	48 81       	ld	r20, Y
     5cc:	59 81       	ldd	r21, Y+1	; 0x01
     5ce:	41 15       	cp	r20, r1
     5d0:	51 05       	cpc	r21, r1
     5d2:	a9 f0       	breq	.+42     	; 0x5fe <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     5d4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     5d6:	2e 81       	ldd	r18, Y+6	; 0x06
     5d8:	3f 81       	ldd	r19, Y+7	; 0x07
     5da:	28 0f       	add	r18, r24
     5dc:	31 1d       	adc	r19, r1
     5de:	3f 83       	std	Y+7, r19	; 0x07
     5e0:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     5e2:	8a 81       	ldd	r24, Y+2	; 0x02
     5e4:	9b 81       	ldd	r25, Y+3	; 0x03
     5e6:	28 17       	cp	r18, r24
     5e8:	39 07       	cpc	r19, r25
     5ea:	10 f0       	brcs	.+4      	; 0x5f0 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     5ec:	5f 83       	std	Y+7, r21	; 0x07
     5ee:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     5f0:	4c 8d       	ldd	r20, Y+28	; 0x1c
     5f2:	6e 81       	ldd	r22, Y+6	; 0x06
     5f4:	7f 81       	ldd	r23, Y+7	; 0x07
     5f6:	cf 01       	movw	r24, r30
     5f8:	50 e0       	ldi	r21, 0x00	; 0
     5fa:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
     5fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
     600:	81 50       	subi	r24, 0x01	; 1
     602:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     604:	8d 8d       	ldd	r24, Y+29	; 0x1d
     606:	8f 3f       	cpi	r24, 0xFF	; 255
     608:	69 f4       	brne	.+26     	; 0x624 <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     60a:	88 85       	ldd	r24, Y+8	; 0x08
     60c:	88 23       	and	r24, r24
     60e:	61 f0       	breq	.+24     	; 0x628 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     610:	ce 01       	movw	r24, r28
     612:	08 96       	adiw	r24, 0x08	; 8
     614:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
     618:	88 23       	and	r24, r24
     61a:	31 f0       	breq	.+12     	; 0x628 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     61c:	81 e0       	ldi	r24, 0x01	; 1
     61e:	f8 01       	movw	r30, r16
     620:	80 83       	st	Z, r24
     622:	03 c0       	rjmp	.+6      	; 0x62a <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     624:	8f 5f       	subi	r24, 0xFF	; 255
     626:	8d 8f       	std	Y+29, r24	; 0x1d
     628:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     62a:	df 91       	pop	r29
     62c:	cf 91       	pop	r28
     62e:	1f 91       	pop	r17
     630:	0f 91       	pop	r16
     632:	08 95       	ret

00000634 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     634:	cf 93       	push	r28
     636:	df 93       	push	r29
     638:	ec 01       	movw	r28, r24
     63a:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     63c:	4c 8d       	ldd	r20, Y+28	; 0x1c
     63e:	44 23       	and	r20, r20
     640:	a1 f1       	breq	.+104    	; 0x6aa <prvCopyDataToQueue+0x76>
                pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     642:	88 23       	and	r24, r24
     644:	b1 f4       	brne	.+44     	; 0x672 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     646:	8c 81       	ldd	r24, Y+4	; 0x04
     648:	9d 81       	ldd	r25, Y+5	; 0x05
     64a:	50 e0       	ldi	r21, 0x00	; 0
     64c:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     650:	8c 8d       	ldd	r24, Y+28	; 0x1c
     652:	2c 81       	ldd	r18, Y+4	; 0x04
     654:	3d 81       	ldd	r19, Y+5	; 0x05
     656:	28 0f       	add	r18, r24
     658:	31 1d       	adc	r19, r1
     65a:	3d 83       	std	Y+5, r19	; 0x05
     65c:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     65e:	8a 81       	ldd	r24, Y+2	; 0x02
     660:	9b 81       	ldd	r25, Y+3	; 0x03
     662:	28 17       	cp	r18, r24
     664:	39 07       	cpc	r19, r25
     666:	08 f1       	brcs	.+66     	; 0x6aa <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     668:	88 81       	ld	r24, Y
     66a:	99 81       	ldd	r25, Y+1	; 0x01
     66c:	9d 83       	std	Y+5, r25	; 0x05
     66e:	8c 83       	std	Y+4, r24	; 0x04
     670:	1c c0       	rjmp	.+56     	; 0x6aa <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     672:	8e 81       	ldd	r24, Y+6	; 0x06
     674:	9f 81       	ldd	r25, Y+7	; 0x07
     676:	50 e0       	ldi	r21, 0x00	; 0
     678:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     67c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	44 27       	eor	r20, r20
     682:	55 27       	eor	r21, r21
     684:	48 1b       	sub	r20, r24
     686:	59 0b       	sbc	r21, r25
     688:	8e 81       	ldd	r24, Y+6	; 0x06
     68a:	9f 81       	ldd	r25, Y+7	; 0x07
     68c:	84 0f       	add	r24, r20
     68e:	95 1f       	adc	r25, r21
     690:	9f 83       	std	Y+7, r25	; 0x07
     692:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     694:	28 81       	ld	r18, Y
     696:	39 81       	ldd	r19, Y+1	; 0x01
     698:	82 17       	cp	r24, r18
     69a:	93 07       	cpc	r25, r19
     69c:	30 f4       	brcc	.+12     	; 0x6aa <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     69e:	8a 81       	ldd	r24, Y+2	; 0x02
     6a0:	9b 81       	ldd	r25, Y+3	; 0x03
     6a2:	84 0f       	add	r24, r20
     6a4:	95 1f       	adc	r25, r21
     6a6:	9f 83       	std	Y+7, r25	; 0x07
     6a8:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     6aa:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6ac:	8f 5f       	subi	r24, 0xFF	; 255
     6ae:	8a 8f       	std	Y+26, r24	; 0x1a
}
     6b0:	df 91       	pop	r29
     6b2:	cf 91       	pop	r28
     6b4:	08 95       	ret

000006b6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     6b6:	0f 93       	push	r16
     6b8:	1f 93       	push	r17
     6ba:	cf 93       	push	r28
     6bc:	df 93       	push	r29
     6be:	ec 01       	movw	r28, r24
     6c0:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     6c2:	9a 8d       	ldd	r25, Y+26	; 0x1a
     6c4:	8b 8d       	ldd	r24, Y+27	; 0x1b
     6c6:	98 17       	cp	r25, r24
     6c8:	10 f0       	brcs	.+4      	; 0x6ce <xQueueGenericSendFromISR+0x18>
     6ca:	80 e0       	ldi	r24, 0x00	; 0
     6cc:	17 c0       	rjmp	.+46     	; 0x6fc <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     6ce:	ce 01       	movw	r24, r28
     6d0:	42 2f       	mov	r20, r18
     6d2:	0e 94 1a 03 	call	0x634	; 0x634 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     6d6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     6d8:	8f 3f       	cpi	r24, 0xFF	; 255
     6da:	69 f4       	brne	.+26     	; 0x6f6 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     6dc:	89 89       	ldd	r24, Y+17	; 0x11
     6de:	88 23       	and	r24, r24
     6e0:	61 f0       	breq	.+24     	; 0x6fa <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     6e2:	ce 01       	movw	r24, r28
     6e4:	41 96       	adiw	r24, 0x11	; 17
     6e6:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
     6ea:	88 23       	and	r24, r24
     6ec:	31 f0       	breq	.+12     	; 0x6fa <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	f8 01       	movw	r30, r16
     6f2:	80 83       	st	Z, r24
     6f4:	03 c0       	rjmp	.+6      	; 0x6fc <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     6f6:	8f 5f       	subi	r24, 0xFF	; 255
     6f8:	8e 8f       	std	Y+30, r24	; 0x1e
     6fa:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     6fc:	df 91       	pop	r29
     6fe:	cf 91       	pop	r28
     700:	1f 91       	pop	r17
     702:	0f 91       	pop	r16
     704:	08 95       	ret

00000706 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     706:	0f 93       	push	r16
     708:	1f 93       	push	r17
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     716:	8c 01       	movw	r16, r24
     718:	0f 5e       	subi	r16, 0xEF	; 239
     71a:	1f 4f       	sbci	r17, 0xFF	; 255
     71c:	0d c0       	rjmp	.+26     	; 0x738 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     71e:	89 89       	ldd	r24, Y+17	; 0x11
     720:	88 23       	and	r24, r24
     722:	69 f0       	breq	.+26     	; 0x73e <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     724:	c8 01       	movw	r24, r16
     726:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
     72a:	88 23       	and	r24, r24
     72c:	11 f0       	breq	.+4      	; 0x732 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     72e:	0e 94 31 06 	call	0xc62	; 0xc62 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     732:	8e 8d       	ldd	r24, Y+30	; 0x1e
     734:	81 50       	subi	r24, 0x01	; 1
     736:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     738:	8e 8d       	ldd	r24, Y+30	; 0x1e
     73a:	18 16       	cp	r1, r24
     73c:	84 f3       	brlt	.-32     	; 0x71e <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     73e:	8f ef       	ldi	r24, 0xFF	; 255
     740:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     742:	0f 90       	pop	r0
     744:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     746:	0f b6       	in	r0, 0x3f	; 63
     748:	f8 94       	cli
     74a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     74c:	8e 01       	movw	r16, r28
     74e:	08 5f       	subi	r16, 0xF8	; 248
     750:	1f 4f       	sbci	r17, 0xFF	; 255
     752:	0d c0       	rjmp	.+26     	; 0x76e <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     754:	88 85       	ldd	r24, Y+8	; 0x08
     756:	88 23       	and	r24, r24
     758:	69 f0       	breq	.+26     	; 0x774 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     75a:	c8 01       	movw	r24, r16
     75c:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
     760:	88 23       	and	r24, r24
     762:	11 f0       	breq	.+4      	; 0x768 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
     764:	0e 94 31 06 	call	0xc62	; 0xc62 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     768:	8d 8d       	ldd	r24, Y+29	; 0x1d
     76a:	81 50       	subi	r24, 0x01	; 1
     76c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     76e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     770:	18 16       	cp	r1, r24
     772:	84 f3       	brlt	.-32     	; 0x754 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     774:	8f ef       	ldi	r24, 0xFF	; 255
     776:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     778:	0f 90       	pop	r0
     77a:	0f be       	out	0x3f, r0	; 63
}
     77c:	df 91       	pop	r29
     77e:	cf 91       	pop	r28
     780:	1f 91       	pop	r17
     782:	0f 91       	pop	r16
     784:	08 95       	ret

00000786 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     786:	7f 92       	push	r7
     788:	8f 92       	push	r8
     78a:	9f 92       	push	r9
     78c:	af 92       	push	r10
     78e:	bf 92       	push	r11
     790:	cf 92       	push	r12
     792:	df 92       	push	r13
     794:	ef 92       	push	r14
     796:	ff 92       	push	r15
     798:	0f 93       	push	r16
     79a:	1f 93       	push	r17
     79c:	df 93       	push	r29
     79e:	cf 93       	push	r28
     7a0:	00 d0       	rcall	.+0      	; 0x7a2 <xQueueGenericReceive+0x1c>
     7a2:	00 d0       	rcall	.+0      	; 0x7a4 <xQueueGenericReceive+0x1e>
     7a4:	0f 92       	push	r0
     7a6:	cd b7       	in	r28, 0x3d	; 61
     7a8:	de b7       	in	r29, 0x3e	; 62
     7aa:	8c 01       	movw	r16, r24
     7ac:	96 2e       	mov	r9, r22
     7ae:	87 2e       	mov	r8, r23
     7b0:	5d 83       	std	Y+5, r21	; 0x05
     7b2:	4c 83       	std	Y+4, r20	; 0x04
     7b4:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     7b6:	91 e1       	ldi	r25, 0x11	; 17
     7b8:	c9 2e       	mov	r12, r25
     7ba:	d1 2c       	mov	r13, r1
     7bc:	c0 0e       	add	r12, r16
     7be:	d1 1e       	adc	r13, r17
     7c0:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     7c2:	7e 01       	movw	r14, r28
     7c4:	08 94       	sec
     7c6:	e1 1c       	adc	r14, r1
     7c8:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     7ca:	84 e0       	ldi	r24, 0x04	; 4
     7cc:	a8 2e       	mov	r10, r24
     7ce:	b1 2c       	mov	r11, r1
     7d0:	ac 0e       	add	r10, r28
     7d2:	bd 1e       	adc	r11, r29
     7d4:	01 c0       	rjmp	.+2      	; 0x7d8 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     7d6:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     7d8:	0f b6       	in	r0, 0x3f	; 63
     7da:	f8 94       	cli
     7dc:	0f 92       	push	r0
		{
  			/* Is there data in the queue now?  To be running we must be
  			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     7de:	f8 01       	movw	r30, r16
     7e0:	82 8d       	ldd	r24, Z+26	; 0x1a
     7e2:	88 23       	and	r24, r24
     7e4:	09 f4       	brne	.+2      	; 0x7e8 <xQueueGenericReceive+0x62>
     7e6:	3e c0       	rjmp	.+124    	; 0x864 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     7e8:	e6 80       	ldd	r14, Z+6	; 0x06
     7ea:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     7ec:	40 81       	ld	r20, Z
     7ee:	51 81       	ldd	r21, Z+1	; 0x01
     7f0:	41 15       	cp	r20, r1
     7f2:	51 05       	cpc	r21, r1
     7f4:	b1 f0       	breq	.+44     	; 0x822 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     7f6:	84 8d       	ldd	r24, Z+28	; 0x1c
     7f8:	97 01       	movw	r18, r14
     7fa:	28 0f       	add	r18, r24
     7fc:	31 1d       	adc	r19, r1
     7fe:	37 83       	std	Z+7, r19	; 0x07
     800:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     802:	82 81       	ldd	r24, Z+2	; 0x02
     804:	93 81       	ldd	r25, Z+3	; 0x03
     806:	28 17       	cp	r18, r24
     808:	39 07       	cpc	r19, r25
     80a:	10 f0       	brcs	.+4      	; 0x810 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     80c:	57 83       	std	Z+7, r21	; 0x07
     80e:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     810:	f8 01       	movw	r30, r16
     812:	44 8d       	ldd	r20, Z+28	; 0x1c
     814:	66 81       	ldd	r22, Z+6	; 0x06
     816:	77 81       	ldd	r23, Z+7	; 0x07
     818:	89 2d       	mov	r24, r9
     81a:	98 2d       	mov	r25, r8
     81c:	50 e0       	ldi	r21, 0x00	; 0
     81e:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
     822:	77 20       	and	r7, r7
     824:	71 f4       	brne	.+28     	; 0x842 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     826:	f8 01       	movw	r30, r16
     828:	82 8d       	ldd	r24, Z+26	; 0x1a
     82a:	81 50       	subi	r24, 0x01	; 1
     82c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     82e:	80 85       	ldd	r24, Z+8	; 0x08
     830:	88 23       	and	r24, r24
     832:	a1 f0       	breq	.+40     	; 0x85c <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     834:	c8 01       	movw	r24, r16
     836:	08 96       	adiw	r24, 0x08	; 8
     838:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
     83c:	81 30       	cpi	r24, 0x01	; 1
     83e:	71 f4       	brne	.+28     	; 0x85c <xQueueGenericReceive+0xd6>
     840:	0b c0       	rjmp	.+22     	; 0x858 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     842:	f8 01       	movw	r30, r16
     844:	f7 82       	std	Z+7, r15	; 0x07
     846:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     848:	81 89       	ldd	r24, Z+17	; 0x11
     84a:	88 23       	and	r24, r24
     84c:	39 f0       	breq	.+14     	; 0x85c <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     84e:	c6 01       	movw	r24, r12
     850:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
     854:	88 23       	and	r24, r24
     856:	11 f0       	breq	.+4      	; 0x85c <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							taskYIELD();
     858:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     85c:	0f 90       	pop	r0
     85e:	0f be       	out	0x3f, r0	; 63
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	4a c0       	rjmp	.+148    	; 0x8f8 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     864:	8c 81       	ldd	r24, Y+4	; 0x04
     866:	9d 81       	ldd	r25, Y+5	; 0x05
     868:	89 2b       	or	r24, r25
     86a:	19 f4       	brne	.+6      	; 0x872 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     86c:	0f 90       	pop	r0
     86e:	0f be       	out	0x3f, r0	; 63
     870:	42 c0       	rjmp	.+132    	; 0x8f6 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     872:	22 23       	and	r18, r18
     874:	19 f4       	brne	.+6      	; 0x87c <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     876:	c7 01       	movw	r24, r14
     878:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     87c:	0f 90       	pop	r0
     87e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     880:	0e 94 96 05 	call	0xb2c	; 0xb2c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     884:	0f b6       	in	r0, 0x3f	; 63
     886:	f8 94       	cli
     888:	0f 92       	push	r0
     88a:	f8 01       	movw	r30, r16
     88c:	85 8d       	ldd	r24, Z+29	; 0x1d
     88e:	8f 3f       	cpi	r24, 0xFF	; 255
     890:	09 f4       	brne	.+2      	; 0x894 <xQueueGenericReceive+0x10e>
     892:	15 8e       	std	Z+29, r1	; 0x1d
     894:	f8 01       	movw	r30, r16
     896:	86 8d       	ldd	r24, Z+30	; 0x1e
     898:	8f 3f       	cpi	r24, 0xFF	; 255
     89a:	09 f4       	brne	.+2      	; 0x89e <xQueueGenericReceive+0x118>
     89c:	16 8e       	std	Z+30, r1	; 0x1e
     89e:	0f 90       	pop	r0
     8a0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     8a2:	c7 01       	movw	r24, r14
     8a4:	b5 01       	movw	r22, r10
     8a6:	0e 94 f7 05 	call	0xbee	; 0xbee <xTaskCheckForTimeOut>
     8aa:	88 23       	and	r24, r24
     8ac:	f9 f4       	brne	.+62     	; 0x8ec <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     8ae:	0f b6       	in	r0, 0x3f	; 63
     8b0:	f8 94       	cli
     8b2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     8b4:	f8 01       	movw	r30, r16
     8b6:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     8b8:	0f 90       	pop	r0
     8ba:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
     8bc:	88 23       	and	r24, r24
     8be:	81 f4       	brne	.+32     	; 0x8e0 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     8c0:	6c 81       	ldd	r22, Y+4	; 0x04
     8c2:	7d 81       	ldd	r23, Y+5	; 0x05
     8c4:	c6 01       	movw	r24, r12
     8c6:	0e 94 ee 06 	call	0xddc	; 0xddc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     8ca:	c8 01       	movw	r24, r16
     8cc:	0e 94 83 03 	call	0x706	; 0x706 <prvUnlockQueue>
				if( !xTaskResumeAll() )
     8d0:	0e 94 27 07 	call	0xe4e	; 0xe4e <xTaskResumeAll>
     8d4:	88 23       	and	r24, r24
     8d6:	09 f0       	breq	.+2      	; 0x8da <xQueueGenericReceive+0x154>
     8d8:	7e cf       	rjmp	.-260    	; 0x7d6 <xQueueGenericReceive+0x50>
				{
					taskYIELD();
     8da:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
     8de:	7b cf       	rjmp	.-266    	; 0x7d6 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     8e0:	c8 01       	movw	r24, r16
     8e2:	0e 94 83 03 	call	0x706	; 0x706 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     8e6:	0e 94 27 07 	call	0xe4e	; 0xe4e <xTaskResumeAll>
     8ea:	75 cf       	rjmp	.-278    	; 0x7d6 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     8ec:	c8 01       	movw	r24, r16
     8ee:	0e 94 83 03 	call	0x706	; 0x706 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     8f2:	0e 94 27 07 	call	0xe4e	; 0xe4e <xTaskResumeAll>
     8f6:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
     8f8:	0f 90       	pop	r0
     8fa:	0f 90       	pop	r0
     8fc:	0f 90       	pop	r0
     8fe:	0f 90       	pop	r0
     900:	0f 90       	pop	r0
     902:	cf 91       	pop	r28
     904:	df 91       	pop	r29
     906:	1f 91       	pop	r17
     908:	0f 91       	pop	r16
     90a:	ff 90       	pop	r15
     90c:	ef 90       	pop	r14
     90e:	df 90       	pop	r13
     910:	cf 90       	pop	r12
     912:	bf 90       	pop	r11
     914:	af 90       	pop	r10
     916:	9f 90       	pop	r9
     918:	8f 90       	pop	r8
     91a:	7f 90       	pop	r7
     91c:	08 95       	ret

0000091e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     91e:	7f 92       	push	r7
     920:	8f 92       	push	r8
     922:	9f 92       	push	r9
     924:	af 92       	push	r10
     926:	bf 92       	push	r11
     928:	cf 92       	push	r12
     92a:	df 92       	push	r13
     92c:	ef 92       	push	r14
     92e:	ff 92       	push	r15
     930:	0f 93       	push	r16
     932:	1f 93       	push	r17
     934:	df 93       	push	r29
     936:	cf 93       	push	r28
     938:	00 d0       	rcall	.+0      	; 0x93a <xQueueGenericSend+0x1c>
     93a:	00 d0       	rcall	.+0      	; 0x93c <xQueueGenericSend+0x1e>
     93c:	0f 92       	push	r0
     93e:	cd b7       	in	r28, 0x3d	; 61
     940:	de b7       	in	r29, 0x3e	; 62
     942:	8c 01       	movw	r16, r24
     944:	6b 01       	movw	r12, r22
     946:	5d 83       	std	Y+5, r21	; 0x05
     948:	4c 83       	std	Y+4, r20	; 0x04
     94a:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     94c:	48 e0       	ldi	r20, 0x08	; 8
     94e:	e4 2e       	mov	r14, r20
     950:	f1 2c       	mov	r15, r1
     952:	e8 0e       	add	r14, r24
     954:	f9 1e       	adc	r15, r25
     956:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     958:	5e 01       	movw	r10, r28
     95a:	08 94       	sec
     95c:	a1 1c       	adc	r10, r1
     95e:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     960:	34 e0       	ldi	r19, 0x04	; 4
     962:	83 2e       	mov	r8, r19
     964:	91 2c       	mov	r9, r1
     966:	8c 0e       	add	r8, r28
     968:	9d 1e       	adc	r9, r29
     96a:	01 c0       	rjmp	.+2      	; 0x96e <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     96c:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     96e:	0f b6       	in	r0, 0x3f	; 63
     970:	f8 94       	cli
     972:	0f 92       	push	r0
		{
  			/* Is there room on the queue now?  To be running we must be
  			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     974:	f8 01       	movw	r30, r16
     976:	92 8d       	ldd	r25, Z+26	; 0x1a
     978:	83 8d       	ldd	r24, Z+27	; 0x1b
     97a:	98 17       	cp	r25, r24
     97c:	a8 f4       	brcc	.+42     	; 0x9a8 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     97e:	c8 01       	movw	r24, r16
     980:	b6 01       	movw	r22, r12
     982:	47 2d       	mov	r20, r7
     984:	0e 94 1a 03 	call	0x634	; 0x634 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     988:	f8 01       	movw	r30, r16
     98a:	81 89       	ldd	r24, Z+17	; 0x11
     98c:	88 23       	and	r24, r24
     98e:	41 f0       	breq	.+16     	; 0x9a0 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     990:	c8 01       	movw	r24, r16
     992:	41 96       	adiw	r24, 0x11	; 17
     994:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
     998:	81 30       	cpi	r24, 0x01	; 1
     99a:	11 f4       	brne	.+4      	; 0x9a0 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						taskYIELD();
     99c:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
     9a4:	81 e0       	ldi	r24, 0x01	; 1
     9a6:	4c c0       	rjmp	.+152    	; 0xa40 <xQueueGenericSend+0x122>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     9a8:	8c 81       	ldd	r24, Y+4	; 0x04
     9aa:	9d 81       	ldd	r25, Y+5	; 0x05
     9ac:	89 2b       	or	r24, r25
     9ae:	19 f4       	brne	.+6      	; 0x9b6 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     9b0:	0f 90       	pop	r0
     9b2:	0f be       	out	0x3f, r0	; 63
     9b4:	44 c0       	rjmp	.+136    	; 0xa3e <xQueueGenericSend+0x120>
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
     9b6:	22 23       	and	r18, r18
     9b8:	19 f4       	brne	.+6      	; 0x9c0 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     9ba:	c5 01       	movw	r24, r10
     9bc:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     9c0:	0f 90       	pop	r0
     9c2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     9c4:	0e 94 96 05 	call	0xb2c	; 0xb2c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     9c8:	0f b6       	in	r0, 0x3f	; 63
     9ca:	f8 94       	cli
     9cc:	0f 92       	push	r0
     9ce:	f8 01       	movw	r30, r16
     9d0:	85 8d       	ldd	r24, Z+29	; 0x1d
     9d2:	8f 3f       	cpi	r24, 0xFF	; 255
     9d4:	09 f4       	brne	.+2      	; 0x9d8 <xQueueGenericSend+0xba>
     9d6:	15 8e       	std	Z+29, r1	; 0x1d
     9d8:	f8 01       	movw	r30, r16
     9da:	86 8d       	ldd	r24, Z+30	; 0x1e
     9dc:	8f 3f       	cpi	r24, 0xFF	; 255
     9de:	09 f4       	brne	.+2      	; 0x9e2 <xQueueGenericSend+0xc4>
     9e0:	16 8e       	std	Z+30, r1	; 0x1e
     9e2:	0f 90       	pop	r0
     9e4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     9e6:	c5 01       	movw	r24, r10
     9e8:	b4 01       	movw	r22, r8
     9ea:	0e 94 f7 05 	call	0xbee	; 0xbee <xTaskCheckForTimeOut>
     9ee:	88 23       	and	r24, r24
     9f0:	09 f5       	brne	.+66     	; 0xa34 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     9f2:	0f b6       	in	r0, 0x3f	; 63
     9f4:	f8 94       	cli
     9f6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     9f8:	f8 01       	movw	r30, r16
     9fa:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     9fc:	0f 90       	pop	r0
     9fe:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
     a00:	f8 01       	movw	r30, r16
     a02:	83 8d       	ldd	r24, Z+27	; 0x1b
     a04:	98 17       	cp	r25, r24
     a06:	81 f4       	brne	.+32     	; 0xa28 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     a08:	6c 81       	ldd	r22, Y+4	; 0x04
     a0a:	7d 81       	ldd	r23, Y+5	; 0x05
     a0c:	c7 01       	movw	r24, r14
     a0e:	0e 94 ee 06 	call	0xddc	; 0xddc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     a12:	c8 01       	movw	r24, r16
     a14:	0e 94 83 03 	call	0x706	; 0x706 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
     a18:	0e 94 27 07 	call	0xe4e	; 0xe4e <xTaskResumeAll>
     a1c:	88 23       	and	r24, r24
     a1e:	09 f0       	breq	.+2      	; 0xa22 <xQueueGenericSend+0x104>
     a20:	a5 cf       	rjmp	.-182    	; 0x96c <xQueueGenericSend+0x4e>
				{
					taskYIELD();
     a22:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
     a26:	a2 cf       	rjmp	.-188    	; 0x96c <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     a28:	c8 01       	movw	r24, r16
     a2a:	0e 94 83 03 	call	0x706	; 0x706 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     a2e:	0e 94 27 07 	call	0xe4e	; 0xe4e <xTaskResumeAll>
     a32:	9c cf       	rjmp	.-200    	; 0x96c <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     a34:	c8 01       	movw	r24, r16
     a36:	0e 94 83 03 	call	0x706	; 0x706 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     a3a:	0e 94 27 07 	call	0xe4e	; 0xe4e <xTaskResumeAll>
     a3e:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
     a40:	0f 90       	pop	r0
     a42:	0f 90       	pop	r0
     a44:	0f 90       	pop	r0
     a46:	0f 90       	pop	r0
     a48:	0f 90       	pop	r0
     a4a:	cf 91       	pop	r28
     a4c:	df 91       	pop	r29
     a4e:	1f 91       	pop	r17
     a50:	0f 91       	pop	r16
     a52:	ff 90       	pop	r15
     a54:	ef 90       	pop	r14
     a56:	df 90       	pop	r13
     a58:	cf 90       	pop	r12
     a5a:	bf 90       	pop	r11
     a5c:	af 90       	pop	r10
     a5e:	9f 90       	pop	r9
     a60:	8f 90       	pop	r8
     a62:	7f 90       	pop	r7
     a64:	08 95       	ret

00000a66 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     a66:	8f 92       	push	r8
     a68:	9f 92       	push	r9
     a6a:	af 92       	push	r10
     a6c:	bf 92       	push	r11
     a6e:	cf 92       	push	r12
     a70:	df 92       	push	r13
     a72:	ef 92       	push	r14
     a74:	ff 92       	push	r15
     a76:	0f 93       	push	r16
     a78:	1f 93       	push	r17
     a7a:	cf 93       	push	r28
     a7c:	df 93       	push	r29
     a7e:	98 2e       	mov	r9, r24
     a80:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     a82:	88 23       	and	r24, r24
     a84:	09 f4       	brne	.+2      	; 0xa88 <xQueueCreate+0x22>
     a86:	42 c0       	rjmp	.+132    	; 0xb0c <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     a88:	8f e1       	ldi	r24, 0x1F	; 31
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	0e 94 58 09 	call	0x12b0	; 0x12b0 <pvPortMalloc>
     a90:	8c 01       	movw	r16, r24
     a92:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     a94:	00 97       	sbiw	r24, 0x00	; 0
     a96:	e1 f1       	breq	.+120    	; 0xb10 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     a98:	c9 2c       	mov	r12, r9
     a9a:	dd 24       	eor	r13, r13
     a9c:	a8 2c       	mov	r10, r8
     a9e:	bb 24       	eor	r11, r11
     aa0:	ac 9c       	mul	r10, r12
     aa2:	70 01       	movw	r14, r0
     aa4:	ad 9c       	mul	r10, r13
     aa6:	f0 0c       	add	r15, r0
     aa8:	bc 9c       	mul	r11, r12
     aaa:	f0 0c       	add	r15, r0
     aac:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed portCHAR * ) pvPortMalloc( xQueueSizeInBytes );
     aae:	c7 01       	movw	r24, r14
     ab0:	01 96       	adiw	r24, 0x01	; 1
     ab2:	0e 94 58 09 	call	0x12b0	; 0x12b0 <pvPortMalloc>
     ab6:	9c 01       	movw	r18, r24
     ab8:	99 83       	std	Y+1, r25	; 0x01
     aba:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     abc:	00 97       	sbiw	r24, 0x00	; 0
     abe:	19 f1       	breq	.+70     	; 0xb06 <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     ac0:	e8 0e       	add	r14, r24
     ac2:	f9 1e       	adc	r15, r25
     ac4:	fb 82       	std	Y+3, r15	; 0x03
     ac6:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
     ac8:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     aca:	9d 83       	std	Y+5, r25	; 0x05
     acc:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
     ace:	08 94       	sec
     ad0:	c1 08       	sbc	r12, r1
     ad2:	d1 08       	sbc	r13, r1
     ad4:	ca 9c       	mul	r12, r10
     ad6:	c0 01       	movw	r24, r0
     ad8:	cb 9c       	mul	r12, r11
     ada:	90 0d       	add	r25, r0
     adc:	da 9c       	mul	r13, r10
     ade:	90 0d       	add	r25, r0
     ae0:	11 24       	eor	r1, r1
     ae2:	28 0f       	add	r18, r24
     ae4:	39 1f       	adc	r19, r25
     ae6:	3f 83       	std	Y+7, r19	; 0x07
     ae8:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     aea:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     aec:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     aee:	8f ef       	ldi	r24, 0xFF	; 255
     af0:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     af2:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     af4:	c8 01       	movw	r24, r16
     af6:	08 96       	adiw	r24, 0x08	; 8
     af8:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     afc:	c8 01       	movw	r24, r16
     afe:	41 96       	adiw	r24, 0x11	; 17
     b00:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
     b04:	05 c0       	rjmp	.+10     	; 0xb10 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     b06:	c8 01       	movw	r24, r16
     b08:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortFree>
     b0c:	c0 e0       	ldi	r28, 0x00	; 0
     b0e:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
     b10:	ce 01       	movw	r24, r28
     b12:	df 91       	pop	r29
     b14:	cf 91       	pop	r28
     b16:	1f 91       	pop	r17
     b18:	0f 91       	pop	r16
     b1a:	ff 90       	pop	r15
     b1c:	ef 90       	pop	r14
     b1e:	df 90       	pop	r13
     b20:	cf 90       	pop	r12
     b22:	bf 90       	pop	r11
     b24:	af 90       	pop	r10
     b26:	9f 90       	pop	r9
     b28:	8f 90       	pop	r8
     b2a:	08 95       	ret

00000b2c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     b2c:	80 91 46 01 	lds	r24, 0x0146
     b30:	8f 5f       	subi	r24, 0xFF	; 255
     b32:	80 93 46 01 	sts	0x0146, r24
}
     b36:	08 95       	ret

00000b38 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     b38:	0f b6       	in	r0, 0x3f	; 63
     b3a:	f8 94       	cli
     b3c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     b3e:	20 91 44 01 	lds	r18, 0x0144
     b42:	30 91 45 01 	lds	r19, 0x0145
	}
	taskEXIT_CRITICAL();
     b46:	0f 90       	pop	r0
     b48:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     b4a:	c9 01       	movw	r24, r18
     b4c:	08 95       	ret

00000b4e <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     b4e:	80 91 49 01 	lds	r24, 0x0149
}
     b52:	08 95       	ret

00000b54 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     b54:	80 91 46 01 	lds	r24, 0x0146
     b58:	88 23       	and	r24, r24
     b5a:	51 f0       	breq	.+20     	; 0xb70 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     b5c:	81 e0       	ldi	r24, 0x01	; 1
     b5e:	80 93 42 01 	sts	0x0142, r24
     b62:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
     b64:	80 91 47 01 	lds	r24, 0x0147
     b68:	81 50       	subi	r24, 0x01	; 1
     b6a:	80 93 47 01 	sts	0x0147, r24
     b6e:	01 c0       	rjmp	.+2      	; 0xb72 <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
     b70:	99 e0       	ldi	r25, 0x09	; 9
     b72:	e0 91 47 01 	lds	r30, 0x0147
     b76:	e9 9f       	mul	r30, r25
     b78:	f0 01       	movw	r30, r0
     b7a:	11 24       	eor	r1, r1
     b7c:	e3 5b       	subi	r30, 0xB3	; 179
     b7e:	fe 4f       	sbci	r31, 0xFE	; 254
     b80:	80 81       	ld	r24, Z
     b82:	88 23       	and	r24, r24
     b84:	79 f3       	breq	.-34     	; 0xb64 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
     b86:	90 91 47 01 	lds	r25, 0x0147
     b8a:	89 e0       	ldi	r24, 0x09	; 9
     b8c:	98 9f       	mul	r25, r24
     b8e:	d0 01       	movw	r26, r0
     b90:	11 24       	eor	r1, r1
     b92:	a3 5b       	subi	r26, 0xB3	; 179
     b94:	be 4f       	sbci	r27, 0xFE	; 254
     b96:	11 96       	adiw	r26, 0x01	; 1
     b98:	ed 91       	ld	r30, X+
     b9a:	fc 91       	ld	r31, X
     b9c:	12 97       	sbiw	r26, 0x02	; 2
     b9e:	02 80       	ldd	r0, Z+2	; 0x02
     ba0:	f3 81       	ldd	r31, Z+3	; 0x03
     ba2:	e0 2d       	mov	r30, r0
     ba4:	12 96       	adiw	r26, 0x02	; 2
     ba6:	fc 93       	st	X, r31
     ba8:	ee 93       	st	-X, r30
     baa:	11 97       	sbiw	r26, 0x01	; 1
     bac:	cd 01       	movw	r24, r26
     bae:	03 96       	adiw	r24, 0x03	; 3
     bb0:	e8 17       	cp	r30, r24
     bb2:	f9 07       	cpc	r31, r25
     bb4:	31 f4       	brne	.+12     	; 0xbc2 <vTaskSwitchContext+0x6e>
     bb6:	82 81       	ldd	r24, Z+2	; 0x02
     bb8:	93 81       	ldd	r25, Z+3	; 0x03
     bba:	12 96       	adiw	r26, 0x02	; 2
     bbc:	9c 93       	st	X, r25
     bbe:	8e 93       	st	-X, r24
     bc0:	11 97       	sbiw	r26, 0x01	; 1
     bc2:	11 96       	adiw	r26, 0x01	; 1
     bc4:	ed 91       	ld	r30, X+
     bc6:	fc 91       	ld	r31, X
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	86 81       	ldd	r24, Z+6	; 0x06
     bcc:	97 81       	ldd	r25, Z+7	; 0x07
     bce:	90 93 41 01 	sts	0x0141, r25
     bd2:	80 93 40 01 	sts	0x0140, r24
     bd6:	08 95       	ret

00000bd8 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
     bd8:	fc 01       	movw	r30, r24
    pxTimeOut->xOverflowCount = xNumOfOverflows;
     bda:	80 91 43 01 	lds	r24, 0x0143
     bde:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
     be0:	80 91 44 01 	lds	r24, 0x0144
     be4:	90 91 45 01 	lds	r25, 0x0145
     be8:	92 83       	std	Z+2, r25	; 0x02
     bea:	81 83       	std	Z+1, r24	; 0x01
}
     bec:	08 95       	ret

00000bee <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
     bee:	fc 01       	movw	r30, r24
     bf0:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
     bf2:	0f b6       	in	r0, 0x3f	; 63
     bf4:	f8 94       	cli
     bf6:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
     bf8:	90 91 43 01 	lds	r25, 0x0143
     bfc:	80 81       	ld	r24, Z
     bfe:	98 17       	cp	r25, r24
     c00:	49 f0       	breq	.+18     	; 0xc14 <xTaskCheckForTimeOut+0x26>
     c02:	20 91 44 01 	lds	r18, 0x0144
     c06:	30 91 45 01 	lds	r19, 0x0145
     c0a:	81 81       	ldd	r24, Z+1	; 0x01
     c0c:	92 81       	ldd	r25, Z+2	; 0x02
     c0e:	28 17       	cp	r18, r24
     c10:	39 07       	cpc	r19, r25
     c12:	18 f5       	brcc	.+70     	; 0xc5a <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) < ( portTickType ) *pxTicksToWait )
     c14:	80 91 44 01 	lds	r24, 0x0144
     c18:	90 91 45 01 	lds	r25, 0x0145
     c1c:	21 81       	ldd	r18, Z+1	; 0x01
     c1e:	32 81       	ldd	r19, Z+2	; 0x02
     c20:	4d 91       	ld	r20, X+
     c22:	5c 91       	ld	r21, X
     c24:	11 97       	sbiw	r26, 0x01	; 1
     c26:	82 1b       	sub	r24, r18
     c28:	93 0b       	sbc	r25, r19
     c2a:	84 17       	cp	r24, r20
     c2c:	95 07       	cpc	r25, r21
     c2e:	a8 f4       	brcc	.+42     	; 0xc5a <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
     c30:	80 91 44 01 	lds	r24, 0x0144
     c34:	90 91 45 01 	lds	r25, 0x0145
     c38:	28 1b       	sub	r18, r24
     c3a:	39 0b       	sbc	r19, r25
     c3c:	24 0f       	add	r18, r20
     c3e:	35 1f       	adc	r19, r21
     c40:	2d 93       	st	X+, r18
     c42:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    pxTimeOut->xOverflowCount = xNumOfOverflows;
     c44:	80 91 43 01 	lds	r24, 0x0143
     c48:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
     c4a:	80 91 44 01 	lds	r24, 0x0144
     c4e:	90 91 45 01 	lds	r25, 0x0145
     c52:	92 83       	std	Z+2, r25	; 0x02
     c54:	81 83       	std	Z+1, r24	; 0x01
     c56:	80 e0       	ldi	r24, 0x00	; 0
     c58:	01 c0       	rjmp	.+2      	; 0xc5c <xTaskCheckForTimeOut+0x6e>
     c5a:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
     c5c:	0f 90       	pop	r0
     c5e:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
     c60:	08 95       	ret

00000c62 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
     c62:	81 e0       	ldi	r24, 0x01	; 1
     c64:	80 93 42 01 	sts	0x0142, r24
}
     c68:	08 95       	ret

00000c6a <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     c6a:	0f 93       	push	r16
     c6c:	1f 93       	push	r17
     c6e:	cf 93       	push	r28
     c70:	df 93       	push	r29
     c72:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     c74:	80 81       	ld	r24, Z
     c76:	88 23       	and	r24, r24
     c78:	19 f4       	brne	.+6      	; 0xc80 <xTaskRemoveFromEventList+0x16>
     c7a:	c0 e0       	ldi	r28, 0x00	; 0
     c7c:	d0 e0       	ldi	r29, 0x00	; 0
     c7e:	05 c0       	rjmp	.+10     	; 0xc8a <xTaskRemoveFromEventList+0x20>
     c80:	05 80       	ldd	r0, Z+5	; 0x05
     c82:	f6 81       	ldd	r31, Z+6	; 0x06
     c84:	e0 2d       	mov	r30, r0
     c86:	c6 81       	ldd	r28, Z+6	; 0x06
     c88:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
     c8a:	8e 01       	movw	r16, r28
     c8c:	04 5f       	subi	r16, 0xF4	; 244
     c8e:	1f 4f       	sbci	r17, 0xFF	; 255
     c90:	c8 01       	movw	r24, r16
     c92:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     c96:	80 91 46 01 	lds	r24, 0x0146
     c9a:	88 23       	and	r24, r24
     c9c:	a1 f4       	brne	.+40     	; 0xcc6 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     c9e:	8e 01       	movw	r16, r28
     ca0:	0e 5f       	subi	r16, 0xFE	; 254
     ca2:	1f 4f       	sbci	r17, 0xFF	; 255
     ca4:	c8 01       	movw	r24, r16
     ca6:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
     caa:	9e 89       	ldd	r25, Y+22	; 0x16
     cac:	80 91 47 01 	lds	r24, 0x0147
     cb0:	89 17       	cp	r24, r25
     cb2:	10 f4       	brcc	.+4      	; 0xcb8 <xTaskRemoveFromEventList+0x4e>
     cb4:	90 93 47 01 	sts	0x0147, r25
     cb8:	89 e0       	ldi	r24, 0x09	; 9
     cba:	98 9f       	mul	r25, r24
     cbc:	c0 01       	movw	r24, r0
     cbe:	11 24       	eor	r1, r1
     cc0:	83 5b       	subi	r24, 0xB3	; 179
     cc2:	9e 4f       	sbci	r25, 0xFE	; 254
     cc4:	02 c0       	rjmp	.+4      	; 0xcca <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     cc6:	87 e8       	ldi	r24, 0x87	; 135
     cc8:	91 e0       	ldi	r25, 0x01	; 1
     cca:	b8 01       	movw	r22, r16
     ccc:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
     cd0:	e0 91 40 01 	lds	r30, 0x0140
     cd4:	f0 91 41 01 	lds	r31, 0x0141
     cd8:	20 e0       	ldi	r18, 0x00	; 0
     cda:	9e 89       	ldd	r25, Y+22	; 0x16
     cdc:	86 89       	ldd	r24, Z+22	; 0x16
     cde:	98 17       	cp	r25, r24
     ce0:	08 f0       	brcs	.+2      	; 0xce4 <xTaskRemoveFromEventList+0x7a>
     ce2:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     ce4:	82 2f       	mov	r24, r18
     ce6:	df 91       	pop	r29
     ce8:	cf 91       	pop	r28
     cea:	1f 91       	pop	r17
     cec:	0f 91       	pop	r16
     cee:	08 95       	ret

00000cf0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
     cf0:	ff 92       	push	r15
     cf2:	0f 93       	push	r16
     cf4:	1f 93       	push	r17
     cf6:	cf 93       	push	r28
     cf8:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     cfa:	80 91 46 01 	lds	r24, 0x0146
     cfe:	88 23       	and	r24, r24
     d00:	09 f0       	breq	.+2      	; 0xd04 <vTaskIncrementTick+0x14>
     d02:	61 c0       	rjmp	.+194    	; 0xdc6 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
     d04:	80 91 44 01 	lds	r24, 0x0144
     d08:	90 91 45 01 	lds	r25, 0x0145
     d0c:	01 96       	adiw	r24, 0x01	; 1
     d0e:	90 93 45 01 	sts	0x0145, r25
     d12:	80 93 44 01 	sts	0x0144, r24
		if( xTickCount == ( portTickType ) 0 )
     d16:	80 91 44 01 	lds	r24, 0x0144
     d1a:	90 91 45 01 	lds	r25, 0x0145
     d1e:	89 2b       	or	r24, r25
     d20:	e9 f5       	brne	.+122    	; 0xd9c <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
     d22:	80 91 83 01 	lds	r24, 0x0183
     d26:	90 91 84 01 	lds	r25, 0x0184
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     d2a:	20 91 85 01 	lds	r18, 0x0185
     d2e:	30 91 86 01 	lds	r19, 0x0186
     d32:	30 93 84 01 	sts	0x0184, r19
     d36:	20 93 83 01 	sts	0x0183, r18
			pxOverflowDelayedTaskList = pxTemp;
     d3a:	90 93 86 01 	sts	0x0186, r25
     d3e:	80 93 85 01 	sts	0x0185, r24
            xNumOfOverflows++;
     d42:	80 91 43 01 	lds	r24, 0x0143
     d46:	8f 5f       	subi	r24, 0xFF	; 255
     d48:	80 93 43 01 	sts	0x0143, r24
     d4c:	27 c0       	rjmp	.+78     	; 0xd9c <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     d4e:	20 91 44 01 	lds	r18, 0x0144
     d52:	30 91 45 01 	lds	r19, 0x0145
     d56:	8a 81       	ldd	r24, Y+2	; 0x02
     d58:	9b 81       	ldd	r25, Y+3	; 0x03
     d5a:	28 17       	cp	r18, r24
     d5c:	39 07       	cpc	r19, r25
     d5e:	c0 f1       	brcs	.+112    	; 0xdd0 <vTaskIncrementTick+0xe0>
     d60:	8e 01       	movw	r16, r28
     d62:	0e 5f       	subi	r16, 0xFE	; 254
     d64:	1f 4f       	sbci	r17, 0xFF	; 255
     d66:	c8 01       	movw	r24, r16
     d68:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
     d6c:	8c 89       	ldd	r24, Y+20	; 0x14
     d6e:	9d 89       	ldd	r25, Y+21	; 0x15
     d70:	89 2b       	or	r24, r25
     d72:	21 f0       	breq	.+8      	; 0xd7c <vTaskIncrementTick+0x8c>
     d74:	ce 01       	movw	r24, r28
     d76:	0c 96       	adiw	r24, 0x0c	; 12
     d78:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
     d7c:	9e 89       	ldd	r25, Y+22	; 0x16
     d7e:	80 91 47 01 	lds	r24, 0x0147
     d82:	89 17       	cp	r24, r25
     d84:	10 f4       	brcc	.+4      	; 0xd8a <vTaskIncrementTick+0x9a>
     d86:	90 93 47 01 	sts	0x0147, r25
     d8a:	9f 9d       	mul	r25, r15
     d8c:	c0 01       	movw	r24, r0
     d8e:	11 24       	eor	r1, r1
     d90:	83 5b       	subi	r24, 0xB3	; 179
     d92:	9e 4f       	sbci	r25, 0xFE	; 254
     d94:	b8 01       	movw	r22, r16
     d96:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
     d9a:	02 c0       	rjmp	.+4      	; 0xda0 <vTaskIncrementTick+0xb0>
     d9c:	89 e0       	ldi	r24, 0x09	; 9
     d9e:	f8 2e       	mov	r15, r24
     da0:	e0 91 83 01 	lds	r30, 0x0183
     da4:	f0 91 84 01 	lds	r31, 0x0184
     da8:	80 81       	ld	r24, Z
     daa:	88 23       	and	r24, r24
     dac:	89 f0       	breq	.+34     	; 0xdd0 <vTaskIncrementTick+0xe0>
     dae:	e0 91 83 01 	lds	r30, 0x0183
     db2:	f0 91 84 01 	lds	r31, 0x0184
     db6:	05 80       	ldd	r0, Z+5	; 0x05
     db8:	f6 81       	ldd	r31, Z+6	; 0x06
     dba:	e0 2d       	mov	r30, r0
     dbc:	c6 81       	ldd	r28, Z+6	; 0x06
     dbe:	d7 81       	ldd	r29, Z+7	; 0x07
     dc0:	20 97       	sbiw	r28, 0x00	; 0
     dc2:	29 f6       	brne	.-118    	; 0xd4e <vTaskIncrementTick+0x5e>
     dc4:	05 c0       	rjmp	.+10     	; 0xdd0 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
     dc6:	80 91 48 01 	lds	r24, 0x0148
     dca:	8f 5f       	subi	r24, 0xFF	; 255
     dcc:	80 93 48 01 	sts	0x0148, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
     dd0:	df 91       	pop	r29
     dd2:	cf 91       	pop	r28
     dd4:	1f 91       	pop	r17
     dd6:	0f 91       	pop	r16
     dd8:	ff 90       	pop	r15
     dda:	08 95       	ret

00000ddc <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
     ddc:	0f 93       	push	r16
     dde:	1f 93       	push	r17
     de0:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
     de2:	60 91 40 01 	lds	r22, 0x0140
     de6:	70 91 41 01 	lds	r23, 0x0141
     dea:	64 5f       	subi	r22, 0xF4	; 244
     dec:	7f 4f       	sbci	r23, 0xFF	; 255
     dee:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     df2:	80 91 40 01 	lds	r24, 0x0140
     df6:	90 91 41 01 	lds	r25, 0x0141
     dfa:	02 96       	adiw	r24, 0x02	; 2
     dfc:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
     e00:	80 91 44 01 	lds	r24, 0x0144
     e04:	90 91 45 01 	lds	r25, 0x0145
     e08:	80 0f       	add	r24, r16
     e0a:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     e0c:	e0 91 40 01 	lds	r30, 0x0140
     e10:	f0 91 41 01 	lds	r31, 0x0141
     e14:	93 83       	std	Z+3, r25	; 0x03
     e16:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
     e18:	20 91 44 01 	lds	r18, 0x0144
     e1c:	30 91 45 01 	lds	r19, 0x0145
     e20:	82 17       	cp	r24, r18
     e22:	93 07       	cpc	r25, r19
     e24:	28 f4       	brcc	.+10     	; 0xe30 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     e26:	80 91 85 01 	lds	r24, 0x0185
     e2a:	90 91 86 01 	lds	r25, 0x0186
     e2e:	04 c0       	rjmp	.+8      	; 0xe38 <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     e30:	80 91 83 01 	lds	r24, 0x0183
     e34:	90 91 84 01 	lds	r25, 0x0184
     e38:	60 91 40 01 	lds	r22, 0x0140
     e3c:	70 91 41 01 	lds	r23, 0x0141
     e40:	6e 5f       	subi	r22, 0xFE	; 254
     e42:	7f 4f       	sbci	r23, 0xFF	; 255
     e44:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListInsert>
			}
	}
	#endif
}
     e48:	1f 91       	pop	r17
     e4a:	0f 91       	pop	r16
     e4c:	08 95       	ret

00000e4e <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     e4e:	cf 92       	push	r12
     e50:	df 92       	push	r13
     e52:	ff 92       	push	r15
     e54:	0f 93       	push	r16
     e56:	1f 93       	push	r17
     e58:	df 93       	push	r29
     e5a:	cf 93       	push	r28
     e5c:	0f 92       	push	r0
     e5e:	cd b7       	in	r28, 0x3d	; 61
     e60:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
     e62:	0f b6       	in	r0, 0x3f	; 63
     e64:	f8 94       	cli
     e66:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     e68:	80 91 46 01 	lds	r24, 0x0146
     e6c:	81 50       	subi	r24, 0x01	; 1
     e6e:	80 93 46 01 	sts	0x0146, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     e72:	80 91 46 01 	lds	r24, 0x0146
     e76:	88 23       	and	r24, r24
     e78:	09 f0       	breq	.+2      	; 0xe7c <xTaskResumeAll+0x2e>
     e7a:	5b c0       	rjmp	.+182    	; 0xf32 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
     e7c:	80 91 49 01 	lds	r24, 0x0149
     e80:	88 23       	and	r24, r24
     e82:	09 f4       	brne	.+2      	; 0xe86 <xTaskResumeAll+0x38>
     e84:	56 c0       	rjmp	.+172    	; 0xf32 <xTaskResumeAll+0xe4>
     e86:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
     e88:	99 e0       	ldi	r25, 0x09	; 9
     e8a:	f9 2e       	mov	r15, r25
     e8c:	27 c0       	rjmp	.+78     	; 0xedc <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
     e8e:	c6 01       	movw	r24, r12
     e90:	0c 96       	adiw	r24, 0x0c	; 12
     e92:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
     e96:	86 01       	movw	r16, r12
     e98:	0e 5f       	subi	r16, 0xFE	; 254
     e9a:	1f 4f       	sbci	r17, 0xFF	; 255
     e9c:	c8 01       	movw	r24, r16
     e9e:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     ea2:	d6 01       	movw	r26, r12
     ea4:	56 96       	adiw	r26, 0x16	; 22
     ea6:	9c 91       	ld	r25, X
     ea8:	80 91 47 01 	lds	r24, 0x0147
     eac:	89 17       	cp	r24, r25
     eae:	10 f4       	brcc	.+4      	; 0xeb4 <xTaskResumeAll+0x66>
     eb0:	90 93 47 01 	sts	0x0147, r25
     eb4:	9f 9d       	mul	r25, r15
     eb6:	c0 01       	movw	r24, r0
     eb8:	11 24       	eor	r1, r1
     eba:	83 5b       	subi	r24, 0xB3	; 179
     ebc:	9e 4f       	sbci	r25, 0xFE	; 254
     ebe:	b8 01       	movw	r22, r16
     ec0:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     ec4:	e0 91 40 01 	lds	r30, 0x0140
     ec8:	f0 91 41 01 	lds	r31, 0x0141
     ecc:	d6 01       	movw	r26, r12
     ece:	56 96       	adiw	r26, 0x16	; 22
     ed0:	9c 91       	ld	r25, X
     ed2:	86 89       	ldd	r24, Z+22	; 0x16
     ed4:	98 17       	cp	r25, r24
     ed6:	10 f0       	brcs	.+4      	; 0xedc <xTaskResumeAll+0x8e>
     ed8:	b1 e0       	ldi	r27, 0x01	; 1
     eda:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
     edc:	80 91 87 01 	lds	r24, 0x0187
     ee0:	88 23       	and	r24, r24
     ee2:	49 f0       	breq	.+18     	; 0xef6 <xTaskResumeAll+0xa8>
     ee4:	e0 91 8c 01 	lds	r30, 0x018C
     ee8:	f0 91 8d 01 	lds	r31, 0x018D
     eec:	c6 80       	ldd	r12, Z+6	; 0x06
     eee:	d7 80       	ldd	r13, Z+7	; 0x07
     ef0:	c1 14       	cp	r12, r1
     ef2:	d1 04       	cpc	r13, r1
     ef4:	61 f6       	brne	.-104    	; 0xe8e <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
     ef6:	80 91 48 01 	lds	r24, 0x0148
     efa:	88 23       	and	r24, r24
     efc:	41 f4       	brne	.+16     	; 0xf0e <xTaskResumeAll+0xc0>
     efe:	0c c0       	rjmp	.+24     	; 0xf18 <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
     f00:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vTaskIncrementTick>
						--uxMissedTicks;
     f04:	80 91 48 01 	lds	r24, 0x0148
     f08:	81 50       	subi	r24, 0x01	; 1
     f0a:	80 93 48 01 	sts	0x0148, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
     f0e:	80 91 48 01 	lds	r24, 0x0148
     f12:	88 23       	and	r24, r24
     f14:	a9 f7       	brne	.-22     	; 0xf00 <xTaskResumeAll+0xb2>
     f16:	07 c0       	rjmp	.+14     	; 0xf26 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     f18:	e9 81       	ldd	r30, Y+1	; 0x01
     f1a:	e1 30       	cpi	r30, 0x01	; 1
     f1c:	21 f0       	breq	.+8      	; 0xf26 <xTaskResumeAll+0xd8>
     f1e:	80 91 42 01 	lds	r24, 0x0142
     f22:	81 30       	cpi	r24, 0x01	; 1
     f24:	31 f4       	brne	.+12     	; 0xf32 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
     f26:	10 92 42 01 	sts	0x0142, r1
					taskYIELD();
     f2a:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
     f2e:	81 e0       	ldi	r24, 0x01	; 1
     f30:	01 c0       	rjmp	.+2      	; 0xf34 <xTaskResumeAll+0xe6>
     f32:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
     f34:	0f 90       	pop	r0
     f36:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     f38:	0f 90       	pop	r0
     f3a:	cf 91       	pop	r28
     f3c:	df 91       	pop	r29
     f3e:	1f 91       	pop	r17
     f40:	0f 91       	pop	r16
     f42:	ff 90       	pop	r15
     f44:	df 90       	pop	r13
     f46:	cf 90       	pop	r12
     f48:	08 95       	ret

00000f4a <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
     f4a:	80 91 4d 01 	lds	r24, 0x014D
     f4e:	82 30       	cpi	r24, 0x02	; 2
     f50:	e0 f3       	brcs	.-8      	; 0xf4a <prvIdleTask>
			{
				taskYIELD();
     f52:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
     f56:	f9 cf       	rjmp	.-14     	; 0xf4a <prvIdleTask>

00000f58 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     f58:	0f 93       	push	r16
     f5a:	1f 93       	push	r17
     f5c:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
     f5e:	00 97       	sbiw	r24, 0x00	; 0
     f60:	a1 f1       	breq	.+104    	; 0xfca <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     f62:	80 91 46 01 	lds	r24, 0x0146
     f66:	8f 5f       	subi	r24, 0xFF	; 255
     f68:	80 93 46 01 	sts	0x0146, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     f6c:	00 91 44 01 	lds	r16, 0x0144
     f70:	10 91 45 01 	lds	r17, 0x0145
     f74:	02 0f       	add	r16, r18
     f76:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     f78:	80 91 40 01 	lds	r24, 0x0140
     f7c:	90 91 41 01 	lds	r25, 0x0141
     f80:	02 96       	adiw	r24, 0x02	; 2
     f82:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     f86:	e0 91 40 01 	lds	r30, 0x0140
     f8a:	f0 91 41 01 	lds	r31, 0x0141
     f8e:	13 83       	std	Z+3, r17	; 0x03
     f90:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
     f92:	80 91 44 01 	lds	r24, 0x0144
     f96:	90 91 45 01 	lds	r25, 0x0145
     f9a:	08 17       	cp	r16, r24
     f9c:	19 07       	cpc	r17, r25
     f9e:	28 f4       	brcc	.+10     	; 0xfaa <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     fa0:	80 91 85 01 	lds	r24, 0x0185
     fa4:	90 91 86 01 	lds	r25, 0x0186
     fa8:	04 c0       	rjmp	.+8      	; 0xfb2 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     faa:	80 91 83 01 	lds	r24, 0x0183
     fae:	90 91 84 01 	lds	r25, 0x0184
     fb2:	60 91 40 01 	lds	r22, 0x0140
     fb6:	70 91 41 01 	lds	r23, 0x0141
     fba:	6e 5f       	subi	r22, 0xFE	; 254
     fbc:	7f 4f       	sbci	r23, 0xFF	; 255
     fbe:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
     fc2:	0e 94 27 07 	call	0xe4e	; 0xe4e <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
     fc6:	88 23       	and	r24, r24
     fc8:	11 f4       	brne	.+4      	; 0xfce <vTaskDelay+0x76>
		{
			taskYIELD();
     fca:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
		}
	}
     fce:	1f 91       	pop	r17
     fd0:	0f 91       	pop	r16
     fd2:	08 95       	ret

00000fd4 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     fd4:	cf 93       	push	r28
     fd6:	df 93       	push	r29
     fd8:	fc 01       	movw	r30, r24
     fda:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     fdc:	80 91 46 01 	lds	r24, 0x0146
     fe0:	8f 5f       	subi	r24, 0xFF	; 255
     fe2:	80 93 46 01 	sts	0x0146, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     fe6:	20 81       	ld	r18, Z
     fe8:	31 81       	ldd	r19, Z+1	; 0x01
     fea:	c2 0f       	add	r28, r18
     fec:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
     fee:	80 91 44 01 	lds	r24, 0x0144
     ff2:	90 91 45 01 	lds	r25, 0x0145
     ff6:	82 17       	cp	r24, r18
     ff8:	93 07       	cpc	r25, r19
     ffa:	28 f4       	brcc	.+10     	; 0x1006 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     ffc:	c2 17       	cp	r28, r18
     ffe:	d3 07       	cpc	r29, r19
    1000:	28 f0       	brcs	.+10     	; 0x100c <vTaskDelayUntil+0x38>
    1002:	20 e0       	ldi	r18, 0x00	; 0
    1004:	0c c0       	rjmp	.+24     	; 0x101e <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1006:	c2 17       	cp	r28, r18
    1008:	d3 07       	cpc	r29, r19
    100a:	40 f0       	brcs	.+16     	; 0x101c <vTaskDelayUntil+0x48>
    100c:	80 91 44 01 	lds	r24, 0x0144
    1010:	90 91 45 01 	lds	r25, 0x0145
    1014:	20 e0       	ldi	r18, 0x00	; 0
    1016:	8c 17       	cp	r24, r28
    1018:	9d 07       	cpc	r25, r29
    101a:	08 f4       	brcc	.+2      	; 0x101e <vTaskDelayUntil+0x4a>
    101c:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    101e:	d1 83       	std	Z+1, r29	; 0x01
    1020:	c0 83       	st	Z, r28

			if( xShouldDelay )
    1022:	22 23       	and	r18, r18
    1024:	29 f1       	breq	.+74     	; 0x1070 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1026:	80 91 40 01 	lds	r24, 0x0140
    102a:	90 91 41 01 	lds	r25, 0x0141
    102e:	02 96       	adiw	r24, 0x02	; 2
    1030:	0e 94 89 02 	call	0x512	; 0x512 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1034:	e0 91 40 01 	lds	r30, 0x0140
    1038:	f0 91 41 01 	lds	r31, 0x0141
    103c:	d3 83       	std	Z+3, r29	; 0x03
    103e:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    1040:	80 91 44 01 	lds	r24, 0x0144
    1044:	90 91 45 01 	lds	r25, 0x0145
    1048:	c8 17       	cp	r28, r24
    104a:	d9 07       	cpc	r29, r25
    104c:	28 f4       	brcc	.+10     	; 0x1058 <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    104e:	80 91 85 01 	lds	r24, 0x0185
    1052:	90 91 86 01 	lds	r25, 0x0186
    1056:	04 c0       	rjmp	.+8      	; 0x1060 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1058:	80 91 83 01 	lds	r24, 0x0183
    105c:	90 91 84 01 	lds	r25, 0x0184
    1060:	60 91 40 01 	lds	r22, 0x0140
    1064:	70 91 41 01 	lds	r23, 0x0141
    1068:	6e 5f       	subi	r22, 0xFE	; 254
    106a:	7f 4f       	sbci	r23, 0xFF	; 255
    106c:	0e 94 54 02 	call	0x4a8	; 0x4a8 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1070:	0e 94 27 07 	call	0xe4e	; 0xe4e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    1074:	88 23       	and	r24, r24
    1076:	11 f4       	brne	.+4      	; 0x107c <vTaskDelayUntil+0xa8>
		{
			taskYIELD();
    1078:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
		}
	}
    107c:	df 91       	pop	r29
    107e:	cf 91       	pop	r28
    1080:	08 95       	ret

00001082 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1082:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1084:	10 92 4a 01 	sts	0x014A, r1
	vPortEndScheduler();
    1088:	0e 94 02 0a 	call	0x1404	; 0x1404 <vPortEndScheduler>
}
    108c:	08 95       	ret

0000108e <xTaskCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask )
{
    108e:	2f 92       	push	r2
    1090:	3f 92       	push	r3
    1092:	4f 92       	push	r4
    1094:	5f 92       	push	r5
    1096:	6f 92       	push	r6
    1098:	7f 92       	push	r7
    109a:	9f 92       	push	r9
    109c:	af 92       	push	r10
    109e:	bf 92       	push	r11
    10a0:	cf 92       	push	r12
    10a2:	df 92       	push	r13
    10a4:	ef 92       	push	r14
    10a6:	ff 92       	push	r15
    10a8:	0f 93       	push	r16
    10aa:	1f 93       	push	r17
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	2c 01       	movw	r4, r24
    10b2:	5b 01       	movw	r10, r22
    10b4:	6a 01       	movw	r12, r20
    10b6:	39 01       	movw	r6, r18
    10b8:	90 2e       	mov	r9, r16
    10ba:	17 01       	movw	r2, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    10bc:	81 e2       	ldi	r24, 0x21	; 33
    10be:	90 e0       	ldi	r25, 0x00	; 0
    10c0:	0e 94 58 09 	call	0x12b0	; 0x12b0 <pvPortMalloc>
    10c4:	ec 01       	movw	r28, r24

	if( pxNewTCB != NULL )
    10c6:	00 97       	sbiw	r24, 0x00	; 0
    10c8:	51 f0       	breq	.+20     	; 0x10de <xTaskCreate+0x50>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMalloc( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) );
    10ca:	c6 01       	movw	r24, r12
    10cc:	0e 94 58 09 	call	0x12b0	; 0x12b0 <pvPortMalloc>
    10d0:	98 8f       	std	Y+24, r25	; 0x18
    10d2:	8f 8b       	std	Y+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    10d4:	00 97       	sbiw	r24, 0x00	; 0
    10d6:	29 f4       	brne	.+10     	; 0x10e2 <xTaskCreate+0x54>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    10d8:	ce 01       	movw	r24, r28
    10da:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortFree>
    10de:	8f ef       	ldi	r24, 0xFF	; 255
    10e0:	b0 c0       	rjmp	.+352    	; 0x1242 <xTaskCreate+0x1b4>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    10e2:	65 ea       	ldi	r22, 0xA5	; 165
    10e4:	70 e0       	ldi	r23, 0x00	; 0
    10e6:	a6 01       	movw	r20, r12
    10e8:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <memset>
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned portSHORT ) configMAX_TASK_NAME_LEN );
    10ec:	ce 01       	movw	r24, r28
    10ee:	49 96       	adiw	r24, 0x19	; 25
    10f0:	b5 01       	movw	r22, r10
    10f2:	48 e0       	ldi	r20, 0x08	; 8
    10f4:	50 e0       	ldi	r21, 0x00	; 0
    10f6:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned portSHORT ) configMAX_TASK_NAME_LEN - ( unsigned portSHORT ) 1 ] = '\0';
    10fa:	18 a2       	std	Y+32, r1	; 0x20
    10fc:	83 e0       	ldi	r24, 0x03	; 3
    10fe:	89 15       	cp	r24, r9
    1100:	08 f4       	brcc	.+2      	; 0x1104 <xTaskCreate+0x76>
    1102:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    1104:	0e 8b       	std	Y+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1106:	32 e0       	ldi	r19, 0x02	; 2
    1108:	a3 2e       	mov	r10, r19
    110a:	b1 2c       	mov	r11, r1
    110c:	ac 0e       	add	r10, r28
    110e:	bd 1e       	adc	r11, r29
    1110:	c5 01       	movw	r24, r10
    1112:	0e 94 27 02 	call	0x44e	; 0x44e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1116:	ce 01       	movw	r24, r28
    1118:	0c 96       	adiw	r24, 0x0c	; 12
    111a:	0e 94 27 02 	call	0x44e	; 0x44e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    111e:	d9 87       	std	Y+9, r29	; 0x09
    1120:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1122:	84 e0       	ldi	r24, 0x04	; 4
    1124:	90 e0       	ldi	r25, 0x00	; 0
    1126:	80 1b       	sub	r24, r16
    1128:	91 09       	sbc	r25, r1
    112a:	9d 87       	std	Y+13, r25	; 0x0d
    112c:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    112e:	db 8b       	std	Y+19, r29	; 0x13
    1130:	ca 8b       	std	Y+18, r28	; 0x12

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
    1132:	08 94       	sec
    1134:	c1 08       	sbc	r12, r1
    1136:	d1 08       	sbc	r13, r1
    1138:	8f 89       	ldd	r24, Y+23	; 0x17
    113a:	98 8d       	ldd	r25, Y+24	; 0x18
    113c:	8c 0d       	add	r24, r12
    113e:	9d 1d       	adc	r25, r13
    1140:	b2 01       	movw	r22, r4
    1142:	a3 01       	movw	r20, r6
    1144:	0e 94 7f 09 	call	0x12fe	; 0x12fe <pxPortInitialiseStack>
    1148:	99 83       	std	Y+1, r25	; 0x01
    114a:	88 83       	st	Y, r24

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	f8 94       	cli
    1150:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1152:	80 91 49 01 	lds	r24, 0x0149
    1156:	8f 5f       	subi	r24, 0xFF	; 255
    1158:	80 93 49 01 	sts	0x0149, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    115c:	80 91 49 01 	lds	r24, 0x0149
    1160:	81 30       	cpi	r24, 0x01	; 1
    1162:	69 f5       	brne	.+90     	; 0x11be <xTaskCreate+0x130>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    1164:	d0 93 41 01 	sts	0x0141, r29
    1168:	c0 93 40 01 	sts	0x0140, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    116c:	8d e4       	ldi	r24, 0x4D	; 77
    116e:	91 e0       	ldi	r25, 0x01	; 1
    1170:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
    1174:	86 e5       	ldi	r24, 0x56	; 86
    1176:	91 e0       	ldi	r25, 0x01	; 1
    1178:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
    117c:	8f e5       	ldi	r24, 0x5F	; 95
    117e:	91 e0       	ldi	r25, 0x01	; 1
    1180:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
    1184:	88 e6       	ldi	r24, 0x68	; 104
    1186:	91 e0       	ldi	r25, 0x01	; 1
    1188:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    118c:	21 e7       	ldi	r18, 0x71	; 113
    118e:	e2 2e       	mov	r14, r18
    1190:	21 e0       	ldi	r18, 0x01	; 1
    1192:	f2 2e       	mov	r15, r18
    1194:	c7 01       	movw	r24, r14
    1196:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    119a:	0a e7       	ldi	r16, 0x7A	; 122
    119c:	11 e0       	ldi	r17, 0x01	; 1
    119e:	c8 01       	movw	r24, r16
    11a0:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    11a4:	87 e8       	ldi	r24, 0x87	; 135
    11a6:	91 e0       	ldi	r25, 0x01	; 1
    11a8:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    11ac:	f0 92 84 01 	sts	0x0184, r15
    11b0:	e0 92 83 01 	sts	0x0183, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    11b4:	10 93 86 01 	sts	0x0186, r17
    11b8:	00 93 85 01 	sts	0x0185, r16
    11bc:	0f c0       	rjmp	.+30     	; 0x11dc <xTaskCreate+0x14e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    11be:	80 91 4a 01 	lds	r24, 0x014A
    11c2:	88 23       	and	r24, r24
    11c4:	59 f4       	brne	.+22     	; 0x11dc <xTaskCreate+0x14e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    11c6:	e0 91 40 01 	lds	r30, 0x0140
    11ca:	f0 91 41 01 	lds	r31, 0x0141
    11ce:	86 89       	ldd	r24, Z+22	; 0x16
    11d0:	98 16       	cp	r9, r24
    11d2:	20 f0       	brcs	.+8      	; 0x11dc <xTaskCreate+0x14e>
					{
						pxCurrentTCB = pxNewTCB;
    11d4:	d0 93 41 01 	sts	0x0141, r29
    11d8:	c0 93 40 01 	sts	0x0140, r28
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    11dc:	9e 89       	ldd	r25, Y+22	; 0x16
    11de:	80 91 4b 01 	lds	r24, 0x014B
    11e2:	89 17       	cp	r24, r25
    11e4:	10 f4       	brcc	.+4      	; 0x11ea <xTaskCreate+0x15c>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    11e6:	90 93 4b 01 	sts	0x014B, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    11ea:	80 91 4c 01 	lds	r24, 0x014C
    11ee:	8f 5f       	subi	r24, 0xFF	; 255
    11f0:	80 93 4c 01 	sts	0x014C, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    11f4:	9e 89       	ldd	r25, Y+22	; 0x16
    11f6:	80 91 47 01 	lds	r24, 0x0147
    11fa:	89 17       	cp	r24, r25
    11fc:	10 f4       	brcc	.+4      	; 0x1202 <xTaskCreate+0x174>
    11fe:	90 93 47 01 	sts	0x0147, r25
    1202:	8e 89       	ldd	r24, Y+22	; 0x16
    1204:	29 e0       	ldi	r18, 0x09	; 9
    1206:	82 9f       	mul	r24, r18
    1208:	c0 01       	movw	r24, r0
    120a:	11 24       	eor	r1, r1
    120c:	83 5b       	subi	r24, 0xB3	; 179
    120e:	9e 4f       	sbci	r25, 0xFE	; 254
    1210:	b5 01       	movw	r22, r10
    1212:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    1216:	0f 90       	pop	r0
    1218:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    121a:	21 14       	cp	r2, r1
    121c:	31 04       	cpc	r3, r1
    121e:	19 f0       	breq	.+6      	; 0x1226 <xTaskCreate+0x198>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1220:	f1 01       	movw	r30, r2
    1222:	d1 83       	std	Z+1, r29	; 0x01
    1224:	c0 83       	st	Z, r28
		}

		if( xSchedulerRunning != pdFALSE )
    1226:	80 91 4a 01 	lds	r24, 0x014A
    122a:	88 23       	and	r24, r24
    122c:	49 f0       	breq	.+18     	; 0x1240 <xTaskCreate+0x1b2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    122e:	e0 91 40 01 	lds	r30, 0x0140
    1232:	f0 91 41 01 	lds	r31, 0x0141
    1236:	86 89       	ldd	r24, Z+22	; 0x16
    1238:	89 15       	cp	r24, r9
    123a:	10 f4       	brcc	.+4      	; 0x1240 <xTaskCreate+0x1b2>
			{
				taskYIELD();
    123c:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
    1240:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1242:	df 91       	pop	r29
    1244:	cf 91       	pop	r28
    1246:	1f 91       	pop	r17
    1248:	0f 91       	pop	r16
    124a:	ff 90       	pop	r15
    124c:	ef 90       	pop	r14
    124e:	df 90       	pop	r13
    1250:	cf 90       	pop	r12
    1252:	bf 90       	pop	r11
    1254:	af 90       	pop	r10
    1256:	9f 90       	pop	r9
    1258:	7f 90       	pop	r7
    125a:	6f 90       	pop	r6
    125c:	5f 90       	pop	r5
    125e:	4f 90       	pop	r4
    1260:	3f 90       	pop	r3
    1262:	2f 90       	pop	r2
    1264:	08 95       	ret

00001266 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1266:	ef 92       	push	r14
    1268:	ff 92       	push	r15
    126a:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed portCHAR * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
    126c:	85 ea       	ldi	r24, 0xA5	; 165
    126e:	97 e0       	ldi	r25, 0x07	; 7
    1270:	60 e0       	ldi	r22, 0x00	; 0
    1272:	71 e0       	ldi	r23, 0x01	; 1
    1274:	45 e5       	ldi	r20, 0x55	; 85
    1276:	50 e0       	ldi	r21, 0x00	; 0
    1278:	20 e0       	ldi	r18, 0x00	; 0
    127a:	30 e0       	ldi	r19, 0x00	; 0
    127c:	00 e0       	ldi	r16, 0x00	; 0
    127e:	ee 24       	eor	r14, r14
    1280:	ff 24       	eor	r15, r15
    1282:	0e 94 47 08 	call	0x108e	; 0x108e <xTaskCreate>

	if( xReturn == pdPASS )
    1286:	81 30       	cpi	r24, 0x01	; 1
    1288:	49 f4       	brne	.+18     	; 0x129c <vTaskStartScheduler+0x36>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    128a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    128c:	80 93 4a 01 	sts	0x014A, r24
		xTickCount = ( portTickType ) 0;
    1290:	10 92 45 01 	sts	0x0145, r1
    1294:	10 92 44 01 	sts	0x0144, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    1298:	0e 94 c7 09 	call	0x138e	; 0x138e <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    129c:	0f 91       	pop	r16
    129e:	ff 90       	pop	r15
    12a0:	ef 90       	pop	r14
    12a2:	08 95       	ret

000012a4 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    12a4:	08 95       	ret

000012a6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    12a6:	10 92 91 01 	sts	0x0191, r1
    12aa:	10 92 90 01 	sts	0x0190, r1
}
    12ae:	08 95       	ret

000012b0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    12b0:	0f 93       	push	r16
    12b2:	1f 93       	push	r17
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & heapBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    12ba:	0e 94 96 05 	call	0xb2c	; 0xb2c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    12be:	80 91 90 01 	lds	r24, 0x0190
    12c2:	90 91 91 01 	lds	r25, 0x0191
    12c6:	98 01       	movw	r18, r16
    12c8:	28 0f       	add	r18, r24
    12ca:	39 1f       	adc	r19, r25
    12cc:	42 e0       	ldi	r20, 0x02	; 2
    12ce:	2e 3e       	cpi	r18, 0xEE	; 238
    12d0:	34 07       	cpc	r19, r20
    12d2:	58 f4       	brcc	.+22     	; 0x12ea <pvPortMalloc+0x3a>
    12d4:	82 17       	cp	r24, r18
    12d6:	93 07       	cpc	r25, r19
    12d8:	40 f4       	brcc	.+16     	; 0x12ea <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    12da:	ec 01       	movw	r28, r24
    12dc:	ce 56       	subi	r28, 0x6E	; 110
    12de:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
    12e0:	30 93 91 01 	sts	0x0191, r19
    12e4:	20 93 90 01 	sts	0x0190, r18
    12e8:	02 c0       	rjmp	.+4      	; 0x12ee <pvPortMalloc+0x3e>
    12ea:	c0 e0       	ldi	r28, 0x00	; 0
    12ec:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    12ee:	0e 94 27 07 	call	0xe4e	; 0xe4e <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    12f2:	ce 01       	movw	r24, r28
    12f4:	df 91       	pop	r29
    12f6:	cf 91       	pop	r28
    12f8:	1f 91       	pop	r17
    12fa:	0f 91       	pop	r16
    12fc:	08 95       	ret

000012fe <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    12fe:	fc 01       	movw	r30, r24
unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1300:	91 e1       	ldi	r25, 0x11	; 17
    1302:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1304:	22 e2       	ldi	r18, 0x22	; 34
    1306:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1308:	83 e3       	ldi	r24, 0x33	; 51
    130a:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    130c:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    130e:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1310:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1312:	80 e8       	ldi	r24, 0x80	; 128
    1314:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1316:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1318:	82 e0       	ldi	r24, 0x02	; 2
    131a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    131c:	83 e0       	ldi	r24, 0x03	; 3
    131e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1320:	84 e0       	ldi	r24, 0x04	; 4
    1322:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1324:	85 e0       	ldi	r24, 0x05	; 5
    1326:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1328:	86 e0       	ldi	r24, 0x06	; 6
    132a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    132c:	87 e0       	ldi	r24, 0x07	; 7
    132e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1330:	88 e0       	ldi	r24, 0x08	; 8
    1332:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1334:	89 e0       	ldi	r24, 0x09	; 9
    1336:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1338:	80 e1       	ldi	r24, 0x10	; 16
    133a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    133c:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    133e:	82 e1       	ldi	r24, 0x12	; 18
    1340:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1342:	83 e1       	ldi	r24, 0x13	; 19
    1344:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1346:	84 e1       	ldi	r24, 0x14	; 20
    1348:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    134a:	85 e1       	ldi	r24, 0x15	; 21
    134c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    134e:	86 e1       	ldi	r24, 0x16	; 22
    1350:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1352:	87 e1       	ldi	r24, 0x17	; 23
    1354:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1356:	88 e1       	ldi	r24, 0x18	; 24
    1358:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    135a:	89 e1       	ldi	r24, 0x19	; 25
    135c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    135e:	80 e2       	ldi	r24, 0x20	; 32
    1360:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1362:	81 e2       	ldi	r24, 0x21	; 33
    1364:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1366:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1368:	83 e2       	ldi	r24, 0x23	; 35
    136a:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    136c:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    136e:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1370:	86 e2       	ldi	r24, 0x26	; 38
    1372:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1374:	87 e2       	ldi	r24, 0x27	; 39
    1376:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1378:	88 e2       	ldi	r24, 0x28	; 40
    137a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    137c:	89 e2       	ldi	r24, 0x29	; 41
    137e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1380:	80 e3       	ldi	r24, 0x30	; 48
    1382:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1384:	81 e3       	ldi	r24, 0x31	; 49
    1386:	82 93       	st	-Z, r24
    1388:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    138a:	cf 01       	movw	r24, r30
    138c:	08 95       	ret

0000138e <xPortStartScheduler>:

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;

	/* Setup clock source and compare match behaviour. */
	TCCR1B = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    138e:	8b e0       	ldi	r24, 0x0B	; 11
    1390:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */

	OCR1A  = (portSHORT)ulCompareMatch;		/* Clock compare value */
    1394:	8a ef       	ldi	r24, 0xFA	; 250
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	90 93 89 00 	sts	0x0089, r25
    139c:	80 93 88 00 	sts	0x0088, r24
	TIMSK1 |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    13a0:	ef e6       	ldi	r30, 0x6F	; 111
    13a2:	f0 e0       	ldi	r31, 0x00	; 0
    13a4:	80 81       	ld	r24, Z
    13a6:	82 60       	ori	r24, 0x02	; 2
    13a8:	80 83       	st	Z, r24

	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    13aa:	a0 91 40 01 	lds	r26, 0x0140
    13ae:	b0 91 41 01 	lds	r27, 0x0141
    13b2:	cd 91       	ld	r28, X+
    13b4:	cd bf       	out	0x3d, r28	; 61
    13b6:	dd 91       	ld	r29, X+
    13b8:	de bf       	out	0x3e, r29	; 62
    13ba:	ff 91       	pop	r31
    13bc:	ef 91       	pop	r30
    13be:	df 91       	pop	r29
    13c0:	cf 91       	pop	r28
    13c2:	bf 91       	pop	r27
    13c4:	af 91       	pop	r26
    13c6:	9f 91       	pop	r25
    13c8:	8f 91       	pop	r24
    13ca:	7f 91       	pop	r23
    13cc:	6f 91       	pop	r22
    13ce:	5f 91       	pop	r21
    13d0:	4f 91       	pop	r20
    13d2:	3f 91       	pop	r19
    13d4:	2f 91       	pop	r18
    13d6:	1f 91       	pop	r17
    13d8:	0f 91       	pop	r16
    13da:	ff 90       	pop	r15
    13dc:	ef 90       	pop	r14
    13de:	df 90       	pop	r13
    13e0:	cf 90       	pop	r12
    13e2:	bf 90       	pop	r11
    13e4:	af 90       	pop	r10
    13e6:	9f 90       	pop	r9
    13e8:	8f 90       	pop	r8
    13ea:	7f 90       	pop	r7
    13ec:	6f 90       	pop	r6
    13ee:	5f 90       	pop	r5
    13f0:	4f 90       	pop	r4
    13f2:	3f 90       	pop	r3
    13f4:	2f 90       	pop	r2
    13f6:	1f 90       	pop	r1
    13f8:	0f 90       	pop	r0
    13fa:	0f be       	out	0x3f, r0	; 63
    13fc:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    13fe:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1400:	81 e0       	ldi	r24, 0x01	; 1
    1402:	08 95       	ret

00001404 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1404:	08 95       	ret

00001406 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1406:	0f 92       	push	r0
    1408:	0f b6       	in	r0, 0x3f	; 63
    140a:	f8 94       	cli
    140c:	0f 92       	push	r0
    140e:	1f 92       	push	r1
    1410:	11 24       	eor	r1, r1
    1412:	2f 92       	push	r2
    1414:	3f 92       	push	r3
    1416:	4f 92       	push	r4
    1418:	5f 92       	push	r5
    141a:	6f 92       	push	r6
    141c:	7f 92       	push	r7
    141e:	8f 92       	push	r8
    1420:	9f 92       	push	r9
    1422:	af 92       	push	r10
    1424:	bf 92       	push	r11
    1426:	cf 92       	push	r12
    1428:	df 92       	push	r13
    142a:	ef 92       	push	r14
    142c:	ff 92       	push	r15
    142e:	0f 93       	push	r16
    1430:	1f 93       	push	r17
    1432:	2f 93       	push	r18
    1434:	3f 93       	push	r19
    1436:	4f 93       	push	r20
    1438:	5f 93       	push	r21
    143a:	6f 93       	push	r22
    143c:	7f 93       	push	r23
    143e:	8f 93       	push	r24
    1440:	9f 93       	push	r25
    1442:	af 93       	push	r26
    1444:	bf 93       	push	r27
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	ef 93       	push	r30
    144c:	ff 93       	push	r31
    144e:	a0 91 40 01 	lds	r26, 0x0140
    1452:	b0 91 41 01 	lds	r27, 0x0141
    1456:	0d b6       	in	r0, 0x3d	; 61
    1458:	0d 92       	st	X+, r0
    145a:	0e b6       	in	r0, 0x3e	; 62
    145c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    145e:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vTaskIncrementTick>
	vTaskSwitchContext();
    1462:	0e 94 aa 05 	call	0xb54	; 0xb54 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1466:	a0 91 40 01 	lds	r26, 0x0140
    146a:	b0 91 41 01 	lds	r27, 0x0141
    146e:	cd 91       	ld	r28, X+
    1470:	cd bf       	out	0x3d, r28	; 61
    1472:	dd 91       	ld	r29, X+
    1474:	de bf       	out	0x3e, r29	; 62
    1476:	ff 91       	pop	r31
    1478:	ef 91       	pop	r30
    147a:	df 91       	pop	r29
    147c:	cf 91       	pop	r28
    147e:	bf 91       	pop	r27
    1480:	af 91       	pop	r26
    1482:	9f 91       	pop	r25
    1484:	8f 91       	pop	r24
    1486:	7f 91       	pop	r23
    1488:	6f 91       	pop	r22
    148a:	5f 91       	pop	r21
    148c:	4f 91       	pop	r20
    148e:	3f 91       	pop	r19
    1490:	2f 91       	pop	r18
    1492:	1f 91       	pop	r17
    1494:	0f 91       	pop	r16
    1496:	ff 90       	pop	r15
    1498:	ef 90       	pop	r14
    149a:	df 90       	pop	r13
    149c:	cf 90       	pop	r12
    149e:	bf 90       	pop	r11
    14a0:	af 90       	pop	r10
    14a2:	9f 90       	pop	r9
    14a4:	8f 90       	pop	r8
    14a6:	7f 90       	pop	r7
    14a8:	6f 90       	pop	r6
    14aa:	5f 90       	pop	r5
    14ac:	4f 90       	pop	r4
    14ae:	3f 90       	pop	r3
    14b0:	2f 90       	pop	r2
    14b2:	1f 90       	pop	r1
    14b4:	0f 90       	pop	r0
    14b6:	0f be       	out	0x3f, r0	; 63
    14b8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14ba:	08 95       	ret

000014bc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    14bc:	0e 94 03 0a 	call	0x1406	; 0x1406 <vPortYieldFromTick>
		asm volatile ( "reti" );
    14c0:	18 95       	reti

000014c2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    14c2:	0f 92       	push	r0
    14c4:	0f b6       	in	r0, 0x3f	; 63
    14c6:	f8 94       	cli
    14c8:	0f 92       	push	r0
    14ca:	1f 92       	push	r1
    14cc:	11 24       	eor	r1, r1
    14ce:	2f 92       	push	r2
    14d0:	3f 92       	push	r3
    14d2:	4f 92       	push	r4
    14d4:	5f 92       	push	r5
    14d6:	6f 92       	push	r6
    14d8:	7f 92       	push	r7
    14da:	8f 92       	push	r8
    14dc:	9f 92       	push	r9
    14de:	af 92       	push	r10
    14e0:	bf 92       	push	r11
    14e2:	cf 92       	push	r12
    14e4:	df 92       	push	r13
    14e6:	ef 92       	push	r14
    14e8:	ff 92       	push	r15
    14ea:	0f 93       	push	r16
    14ec:	1f 93       	push	r17
    14ee:	2f 93       	push	r18
    14f0:	3f 93       	push	r19
    14f2:	4f 93       	push	r20
    14f4:	5f 93       	push	r21
    14f6:	6f 93       	push	r22
    14f8:	7f 93       	push	r23
    14fa:	8f 93       	push	r24
    14fc:	9f 93       	push	r25
    14fe:	af 93       	push	r26
    1500:	bf 93       	push	r27
    1502:	cf 93       	push	r28
    1504:	df 93       	push	r29
    1506:	ef 93       	push	r30
    1508:	ff 93       	push	r31
    150a:	a0 91 40 01 	lds	r26, 0x0140
    150e:	b0 91 41 01 	lds	r27, 0x0141
    1512:	0d b6       	in	r0, 0x3d	; 61
    1514:	0d 92       	st	X+, r0
    1516:	0e b6       	in	r0, 0x3e	; 62
    1518:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    151a:	0e 94 aa 05 	call	0xb54	; 0xb54 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    151e:	a0 91 40 01 	lds	r26, 0x0140
    1522:	b0 91 41 01 	lds	r27, 0x0141
    1526:	cd 91       	ld	r28, X+
    1528:	cd bf       	out	0x3d, r28	; 61
    152a:	dd 91       	ld	r29, X+
    152c:	de bf       	out	0x3e, r29	; 62
    152e:	ff 91       	pop	r31
    1530:	ef 91       	pop	r30
    1532:	df 91       	pop	r29
    1534:	cf 91       	pop	r28
    1536:	bf 91       	pop	r27
    1538:	af 91       	pop	r26
    153a:	9f 91       	pop	r25
    153c:	8f 91       	pop	r24
    153e:	7f 91       	pop	r23
    1540:	6f 91       	pop	r22
    1542:	5f 91       	pop	r21
    1544:	4f 91       	pop	r20
    1546:	3f 91       	pop	r19
    1548:	2f 91       	pop	r18
    154a:	1f 91       	pop	r17
    154c:	0f 91       	pop	r16
    154e:	ff 90       	pop	r15
    1550:	ef 90       	pop	r14
    1552:	df 90       	pop	r13
    1554:	cf 90       	pop	r12
    1556:	bf 90       	pop	r11
    1558:	af 90       	pop	r10
    155a:	9f 90       	pop	r9
    155c:	8f 90       	pop	r8
    155e:	7f 90       	pop	r7
    1560:	6f 90       	pop	r6
    1562:	5f 90       	pop	r5
    1564:	4f 90       	pop	r4
    1566:	3f 90       	pop	r3
    1568:	2f 90       	pop	r2
    156a:	1f 90       	pop	r1
    156c:	0f 90       	pop	r0
    156e:	0f be       	out	0x3f, r0	; 63
    1570:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1572:	08 95       	ret

00001574 <INPUT>:

void INPUT(void *pvParameters){

	while(1){
	
		PORTB = PINC;
    1574:	86 b1       	in	r24, 0x06	; 6
    1576:	85 b9       	out	0x05, r24	; 5
		taskYIELD();
    1578:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <vPortYield>
    157c:	fb cf       	rjmp	.-10     	; 0x1574 <INPUT>

0000157e <main>:
// ######################################################

void INPUT(void *pvParameters);

int main()
{
    157e:	ef 92       	push	r14
    1580:	ff 92       	push	r15
    1582:	0f 93       	push	r16
	DDRC = 0x00;	// configure portC as input
    1584:	17 b8       	out	0x07, r1	; 7
	DDRB = 0xFF;	// configure portB as output
    1586:	8f ef       	ldi	r24, 0xFF	; 255
    1588:	84 b9       	out	0x04, r24	; 4

	xTaskCreate(INPUT,NULL,STACK_SIZE, NULL, 0, NULL);
    158a:	8a eb       	ldi	r24, 0xBA	; 186
    158c:	9a e0       	ldi	r25, 0x0A	; 10
    158e:	60 e0       	ldi	r22, 0x00	; 0
    1590:	70 e0       	ldi	r23, 0x00	; 0
    1592:	44 e6       	ldi	r20, 0x64	; 100
    1594:	50 e0       	ldi	r21, 0x00	; 0
    1596:	20 e0       	ldi	r18, 0x00	; 0
    1598:	30 e0       	ldi	r19, 0x00	; 0
    159a:	00 e0       	ldi	r16, 0x00	; 0
    159c:	ee 24       	eor	r14, r14
    159e:	ff 24       	eor	r15, r15
    15a0:	0e 94 47 08 	call	0x108e	; 0x108e <xTaskCreate>
	
	vTaskStartScheduler();
    15a4:	0e 94 33 09 	call	0x1266	; 0x1266 <vTaskStartScheduler>
		

	return 0;
}
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	90 e0       	ldi	r25, 0x00	; 0
    15ac:	0f 91       	pop	r16
    15ae:	ff 90       	pop	r15
    15b0:	ef 90       	pop	r14
    15b2:	08 95       	ret

000015b4 <memcpy>:
    15b4:	fb 01       	movw	r30, r22
    15b6:	dc 01       	movw	r26, r24
    15b8:	02 c0       	rjmp	.+4      	; 0x15be <memcpy+0xa>
    15ba:	01 90       	ld	r0, Z+
    15bc:	0d 92       	st	X+, r0
    15be:	41 50       	subi	r20, 0x01	; 1
    15c0:	50 40       	sbci	r21, 0x00	; 0
    15c2:	d8 f7       	brcc	.-10     	; 0x15ba <memcpy+0x6>
    15c4:	08 95       	ret

000015c6 <memset>:
    15c6:	dc 01       	movw	r26, r24
    15c8:	01 c0       	rjmp	.+2      	; 0x15cc <memset+0x6>
    15ca:	6d 93       	st	X+, r22
    15cc:	41 50       	subi	r20, 0x01	; 1
    15ce:	50 40       	sbci	r21, 0x00	; 0
    15d0:	e0 f7       	brcc	.-8      	; 0x15ca <memset+0x4>
    15d2:	08 95       	ret

000015d4 <strncpy>:
    15d4:	fb 01       	movw	r30, r22
    15d6:	dc 01       	movw	r26, r24
    15d8:	41 50       	subi	r20, 0x01	; 1
    15da:	50 40       	sbci	r21, 0x00	; 0
    15dc:	48 f0       	brcs	.+18     	; 0x15f0 <strncpy+0x1c>
    15de:	01 90       	ld	r0, Z+
    15e0:	0d 92       	st	X+, r0
    15e2:	00 20       	and	r0, r0
    15e4:	c9 f7       	brne	.-14     	; 0x15d8 <strncpy+0x4>
    15e6:	01 c0       	rjmp	.+2      	; 0x15ea <strncpy+0x16>
    15e8:	1d 92       	st	X+, r1
    15ea:	41 50       	subi	r20, 0x01	; 1
    15ec:	50 40       	sbci	r21, 0x00	; 0
    15ee:	e0 f7       	brcc	.-8      	; 0x15e8 <strncpy+0x14>
    15f0:	08 95       	ret

000015f2 <_exit>:
    15f2:	f8 94       	cli

000015f4 <__stop_program>:
    15f4:	ff cf       	rjmp	.-2      	; 0x15f4 <__stop_program>
